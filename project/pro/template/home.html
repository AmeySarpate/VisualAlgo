{% load static %}
<!DOCTYPE html>
<html lang="en" dir="ltr">

<head>
  <meta charset="utf-8">
  <title></title>
  <link rel="stylesheet" href="{% static 'css/s.css'%}">
  <style media="screen">
  .fa
  {
    text-align: center;

  }
  </style>
</head>

<body>

  <ul>
    <li><button id='nav1' onclick="my1(event)">Djkastra</button></li>
    <li><button id='nav2' onclick="my2(event)">A* algorithm</button></li>
    <li><button id='nav3' onclick="my3(event)">BFS</button></li>
    <li><button id='nav4' onclick="my4(event)">DFS</button></li>
    <li><button id='nav4' onclick="my5(event)">Bidrection Search</button></li>

  </ul>
  <div id="message" style="display:block;height:40px;background-color:orange">

  </div>
  <img id='start' src="{% static 'images/start.png'%}" alt="Photo" width='14px' height='14px' style='margin:0;left:30px;' onclick='stick(event)'>
  <img id='end' src="{% static 'images/end.png'%}" alt="Photo" width='14px' height='14px' style='margin:0;left:60px;' onclick='stick(event)'>
  <img id='pass' src="{% static 'images/pass.png'%}" alt="Photo" width='14px' height='14px' style='margin:0;left:90px;' onclick='stick(event)'>
  <br>
  <div id='graph' unselectable="on" onselectstart="return false;">
    <table style="width:100%">
      {% for row in rows%}
      <tr>


        {% for col in cols %}
        <td id='b_{{row}}_{{col}}' style="width:15px;height:15px;padding-right:0px;margin:0px;">

          <div id="div_{{row}}_{{col}}" style='margin:0px;width:23.8px;height:21.8px;display:block;' onmouseenter='entering(event)' onmousedown="mousedown(event)" onmouseup="mouseup(event)"></div>

        </td>
        {%endfor%}
      </tr>
      {% endfor%}
    </table>

  </div>

</body>

<!--varible declaration and initials-->
<script src="https://use.fontawesome.com/a016dd128e.js"></script>
<script type="text/javascript">
  var start;
  var final;
  var pass;
  var lclicked;
  var rclicked;
  var wall = [];
  var imagedragging = false;
  var path = [];
  var path2 = [];
  var prev = [];
  var prev2 = [];
  var selected_algo;
  var distances = [];
  var distances2=[];
  var middleclicked=false;
  var check_prev_wall = [];
  var obstacles=[];
  var check_prev_obstacles=[];
  var check_prev_pass_exist=false;
  var animate = false;
  var g;

  var x = document.querySelectorAll("div");
  for (i = 1; i < x.length; i++) {
    x[i].style.backgroundColor = "white";
  }
</script>

<!-- class declaration -->
<script type="text/javascript">
  class Graph {
    constructor() {
      this.edges = {};
      this.nodes = [];
    }
    addNode(node) {
      this.nodes.push(node);
      this.edges[node] = [];
    }
    addEdge(node1, node2) {
      this.edges[node1].push(node2);
      this.edges[node2].push(node1);
    }

    addDirectedEdge(node1, node2, weight = 1) {
      this.edges[node1].push({
        node: node2,
        weight: weight
      });
    }

    display() {
      let graph = "";
      this.nodes.forEach(node => {
        graph += node + "->" + this.edges[node].join(", ") + "\n";
      });
      //    console.log(graph);
    }
    bfs(startNode) {
      let distances = {};

      // Stores the reference to previous nodes

      let pq = new Queue();

      // Set distances to all nodes to be infinite except startNode
      distances[startNode] = 0;
      pq.enqueue(startNode, 0);
      this.nodes.forEach(node => {
        if (node !== startNode) distances[node] = Infinity;
        prev[node] = null;
      });

      while (!pq.isEmpty()) {
        let minNode = pq.dequeue();
        let currNode = minNode;

        this.edges[currNode].forEach(neighbor => {
          let alt = distances[currNode] + neighbor.weight;
          if (alt < distances[neighbor.node]) {
            distances[neighbor.node] = alt;
            prev[neighbor.node] = currNode;
            pq.enqueue(neighbor.node);
          }
        });
      }

      var sortable = [];
      for (var n in distances) {
        sortable.push([n, distances[n]]);
      }
      sortable.sort(function(a, b) {
        return a[1] - b[1];
      });
      return sortable;
    }

    djikstraAlgorithm(startNode) {
      let distances = {};

      // Stores the reference to previous nodes

      let pq = new PriorityQueue(this.nodes.length * this.nodes.length);

      // Set distances to all nodes to be infinite except startNode
      distances[startNode] = 0;
      pq.enqueue(startNode);
      this.nodes.forEach(node => {
        if (node !== startNode) distances[node] = Infinity;
        prev[node] = null;
      });

      while (!pq.isEmpty()) {
        let minNode = pq.dequeue();
        let currNode = minNode.data;
        let weight = minNode.priority;
        this.edges[currNode].forEach(neighbor => {
          let alt = distances[currNode] + neighbor.weight;
          if (alt < distances[neighbor.node]) {
            distances[neighbor.node] = alt;
            prev[neighbor.node] = currNode;
            pq.enqueue(neighbor.node, distances[neighbor.node]);
          }
        });
      }

      var sortable = [];
      for (var n in distances) {
        sortable.push([n, distances[n]]);
      }
      sortable.sort(function(a, b) {
        return a[1] - b[1];
      });
      return sortable;
    }
//this is A* algorithm
    A_star(startNode,endNode)
      {

        let distances = {};
        let pred_distances={};
        // Stores the reference to previous nodes
        let final_i=endNode.split("_")[1];
        let final_j=endNode.split("_")[2];
        let pq = new PriorityQueue(this.nodes.length * this.nodes.length);

        for(let i=1;i<={{nrows}};i++)
          {
            for(let j=1;j<={{ncols}};j++)
              {
                pred_distances['b_'+i+'_'+j]=abs(final_j-j)+abs(final_i-i);
              }
          }
        // Set distances to all nodes to be infinite except startNode
        distances[startNode] = 0;
        pq.enqueue(startNode, 0);
        this.nodes.forEach(node => {
          if (node !== startNode) distances[node] = Infinity;
          prev[node] = null;
        });

        while (!pq.isEmpty()) {
          let minNode = pq.dequeue();
          let currNode = minNode.data;
          let weight = minNode.priority;
          this.edges[currNode].forEach(neighbor => {
            let alt = distances[currNode] + neighbor.weight;
            if (alt < distances[neighbor.node]) {
              distances[neighbor.node] = alt;
              prev[neighbor.node] = currNode;
              pq.enqueue(neighbor.node, distances[neighbor.node]);
            }
          });
        }

        var sortable = [];
        for (var n in distances) {
          sortable.push([n, distances[n]+pred_distances[n],distances[n]]);
        }

        sortable.sort(function(a,b){
              if(a[1]<b[1])
              {
                return a[1]-b[1];
              }
              else if(a[1]==b[1])
              {
                return a[2]-b[2];
              }
              else {
                return a[1]-b[1];
              }
        }
      );
        return sortable;


      }




}//end of graph class

class Stack {
   constructor(maxSize) { // Set default max size if not provided
      if (isNaN(maxSize)) {
         maxSize = 1000;
      }
      this.maxSize = maxSize; // Init an array that'll contain the stack values.
      this.container = [];
   }

   display() {
      console.log(this.container);
   }

   isEmpty() {
      return this.container.length === 0;
   }

   isFull() {
      return this.container.length >= this.maxSize;
   }

   push(element) { // Check if stack is full
      if (this.isFull()) {
         console.log("Stack Overflow!");
         return;
      }
      this.container.push(element)
   }

   pop() { // Check if empty
      if (this.isEmpty()) {
         console.log("Stack Underflow!");
          return;
      }
      this.container.pop()
   }
   peek() {
      if (isEmpty()) {
         console.log("Stack Underflow!");
         return;
      }
      return this.container[this.container.length - 1];
   }
   clear() {
      this.container = [];
   }
}

/////////////////////////
class Queue {
   constructor(maxSize) {
      // Set default max size if not provided
      if (isNaN(maxSize)) {
         maxSize = 2000;
      }
      this.maxSize = maxSize;
      // Init an array that'll contain the queue values.
      this.container = [];
    }
   // Helper function to display all values while developing
   display() {
      console.log(this.container);
   }
   // Checks if queue is empty
   isEmpty() {
      return this.container.length === 0;
   }
   // checks if queue is full
   isFull() {
      return this.container.length >= this.maxSize;
   }
   enqueue(element) {
      // Check if Queue is full
      if (this.isFull()) {
         console.log("Queue Overflow!"); return;
      }
      // Since we want to add elements to end, we'll just push them.
      this.container.push(element);
   }
   dequeue() {
      // Check if empty
      if (this.isEmpty()) {
         console.log("Queue Underflow!");
         return;
      }
      return this.container.shift();
   }
   peek() {
      if (this.isEmpty()) {
         console.log("Queue Underflow!");
         return;
      }
      return this.container[0];
   }
   clear() {
      this.container = [];
   }
}



////////////////////
  class PriorityQueue {
    constructor(maxSize) {
      // Set default max size if not provided
      if (isNaN(maxSize)) {
        maxSize = 100;
      }
      this.maxSize = maxSize;
      // Init an array that'll contain the queue values.
      this.container = [];
    }
    // Helper function to display all values while developing
    display() {
      //    console.log(this.container);
    }
    // Checks if queue is empty
    isEmpty() {
      return this.container.length === 0;
    }
    // checks if queue is full
    isFull() {
      return this.container.length >= this.maxSize;
    }
    enqueue(data, priority) {
      // Check if Queue is full
      if (this.isFull()) {
        console.log("Queue Overflow!");
        return;
      }
      let currElem = new this.Element(data, priority);
      let addedFlag = false;
      // Since we want to add elements to end, we'll just push them.
      for (let i = 0; i < this.container.length; i++) {
        if (currElem.priority < this.container[i].priority) {
          this.container.splice(i, 0, currElem);
          addedFlag = true;
          break;
        }
      }
      if (!addedFlag) {
        this.container.push(currElem);
      }
    }
    dequeue() {
      // Check if empty
      if (this.isEmpty()) {
        console.log("Queue Underflow!");
        return;
      }
      return this.container.pop();
    }
    peek() {
      if (isEmpty()) {
        console.log("Queue Underflow!");
        return;
      }
      return this.container[this.container.length - 1];
    }
    clear() {
      this.container = [];
    }
  }


  PriorityQueue.prototype.Element = class {
    constructor(data, priority) {
      this.data = data;
      this.priority = priority;
    }
  };
</script>

<!-- path propagater and highlighter functions -->







<script type="text/javascript">
  function arraysEqual(a, b) {
    if (a === b) return true;
    if (a == null || b == null) return false;
    if (a.length !== b.length) return false;

    // If you don't care about the order of the elements inside
    // the array, you should sort both arrays here.
    // Please note that calling sort on an array will modify that array.
    // you might want to clone your array first.

    for (var i = 0; i < a.length; ++i) {
      if (a[i] !== b[i]) return false;
    }
    return true;
  }
  function abs(x){
    if(x>0)
      return x;
    else
    return -x;
  }


  function pathhighlighter(id) {
    if (id != start) {
      document.getElementById(id).style.backgroundColor = 'yellow';
      document.getElementById('b' + id.slice(3, )).style.border = "0px solid yellow";
      document.getElementById('b' + id.slice(3, )).style.margin = "0px";
    }
  }

  function propagater(id) {
    if (id != start && id != pass && id != final) {
      //  console.log(id +'is going to propagate');
      document.getElementById(id).style.backgroundColor = '#a6dcef';
      document.getElementById('b' + id.slice(3, )).style.border = "0px solid #a6dcef";
      document.getElementById('b' + id.slice(3, )).style.margin = "0px";
    }
  }

  function propagater2(id) {
    //  console.log('------------------------------'+id+'---------------------------');
    if (id != start && id != final && id != pass) {
      document.getElementById(id).style.backgroundColor = 'pink';
      document.getElementById('b' + id.slice(3, )).style.border = "0px solid pink";
      document.getElementById('b' + id.slice(3, )).style.margin = "0px";
    }
  }
  function propagater3(id){
    if (id != start && id != final && id != pass) {
      document.getElementById(id).style.backgroundColor = 'green';
      document.getElementById('b' + id.slice(3, )).style.border = "0px solid pink";
      document.getElementById('b' + id.slice(3, )).style.margin = "0px";
    }
  }
</script>

<!-- sleep function -->
<script type="text/javascript">
  function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
</script>

<!-- other very important breaked function  -->
<script type="text/javascript">
  function graphbuild() {

    var x = document.querySelectorAll("div");
    for (i = 1; i < x.length; i++) {
      x[i].style.backgroundColor = "white";
    }
    var k = document.querySelectorAll('td');
    for (i = 1; i < k.length; i++) {
      k[i].style.border = "1px solid black";
    }
    let g = new Graph();
    for(let i=1;i<={{nrows}};i++)
  {
  for(let j=1;j<={{ncols}};j++)
    {
    g.addNode('b_'+i+'_'+j);
    }
  }


  // for(let i=1;i<={{nrows}};i++)
  //   {
  //   for(let j=1;j<={{ncols}}-1;j++)
  //     {
  //     g.addDirectedEdge('b_'+i+'_'+j,'b_'+i+'_'+(j+1),1);
  //     g.addDirectedEdge('b_'+i+'_'+(j+1),'b_'+i+'_'+j,1);
  //
  //     }
  //   }
  //   for(let i=1;i<={{ncols}};i++)
  //     {
  //     for(let j=1;j<={{nrows}}-1;j++)
  //       {
  //       g.addDirectedEdge('b_'+j+'_'+i,'b_'+(j+1)+'_'+(i),1);
  //       g.addDirectedEdge('b_'+(j+1)+'_'+(i),'b_'+j+'_'+i,1);
  //       }
  //     }
//////$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$






              for(let i=1;i<={{nrows}};i++)
                  {
                    for(let j=1;j<={{ncols}};j++)
                      {
                        if(j>1)
                          {
                            g.addDirectedEdge('b_'+i+'_'+j,'b_'+(i)+'_'+(j-1),1);

                          }


                      }

                  }


                            for(let i=1;i<={{nrows}};i++)
                                {
                                  for(let j=1;j<={{ncols}};j++)
                                    {
                                      if(i<{{nrows}})
                                        {
                                          g.addDirectedEdge('b_'+i+'_'+j,'b_'+(i+1)+'_'+(j),1);

                                        }


                                    }

                                }


                  for(let i=1;i<={{nrows}};i++)
                      {
                        for(let j=1;j<={{ncols}};j++)
                          {
                            if(j<{{ncols}})
                              {
                                g.addDirectedEdge('b_'+i+'_'+j,'b_'+(i)+'_'+(j+1),1);

                              }


                          }

                      }

                  for(let i=1;i<={{nrows}};i++)
                      {
                        for(let j=1;j<={{ncols}};j++)
                          {
                            if(i>1)
                              {
                                g.addDirectedEdge('b_'+i+'_'+j,'b_'+(i-1)+'_'+(j),1);

                              }


                          }

                      }

//////$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

    for (item in wall) {
      document.getElementById('div' + wall[item].slice(1, )).style.backgroundColor = 'black';
      nearest = g.edges[wall[item]];
      for (i in nearest) {
        nearest[i].weight = Infinity;


      }

    }
    for(item in obstacles)
    {
      var element=document.getElementById('div' + obstacles[item].slice(1, ))
      element.classList.add("fa","fa-lock");
      nearest = g.edges[obstacles[item]];
      for (i in nearest) {
        nearest[i].weight = 5;
      }
    }
    for (k in g.edges) {
      for (t in g.edges[k]) {
        if (obstacles.includes(g.edges[k][t].node)) {
          g.edges[k][t].weight = 5;

        }
      }


    }
    for (k in g.edges) {
      for (t in g.edges[k]) {
        if (wall.includes(g.edges[k][t].node)) {
          g.edges[k][t].weight = Infinity;

        }
      }


    }
    return g;
  }
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

async function dfs(g,startNode,animation=true)
{
  var visited=[];
  var prev=[];
  var st = [];

  prev=[];
  //st.push(startNode);
//  st.push(final);
  st.push(startNode);
  // console.log('see the edges');
  // console.log(g.edges);
if(!pass)
{
  while(st.length>0 )
    {
      var curr=st.pop();
      //console.log('see if it is iterable or not');
    //  console.log(g.edges[curr]);

    if(!visited.includes(curr))
          visited.push(curr);
    if(curr==final)
          break;
    if(animation==true)
    {
      setTimeout(function() {
            propagater2('div' + curr.slice(1, ));
          }, 10);
      await sleep(11);

      setTimeout(function() {
            propagater('div' + curr.slice(1, ));
          }, 10);
      await sleep(11);
    }
    else {
        propagater('div' + curr.slice(1, ));
    }

    for(const neighbor of g.edges[curr]){

          if(neighbor.weight!=Infinity && !visited.includes(neighbor.node))
          {
            prev[neighbor.node] = curr;

            st.push(neighbor.node);


          }
                }
  }

    path=[];
    curr = final;
    if (prev[final] == null) {
      console.log('TARGET CANNOT BE REACHED');
    } else {
      while (prev[curr] != null) {
        path.push(prev[curr]);
        curr = prev[curr];
      }
      path.pop();
    }
    document.getElementById('div' + curr.slice(1, )).style.backgroundColor = 'blue';
    for (i in path) {
      if(animation==true)
      {  setTimeout(function() {
  pathhighlighter('div' + path[path.length - i - 1].slice(1, ));
        }, 24);
    await sleep(25);

      }
      else {
        pathhighlighter('div' + path[path.length - i - 1].slice(1, ));
      }



    }


}
else {
  while(st.length>0 )
    {
      var curr=st.pop();
      //console.log('see if it is iterable or not');
    //  console.log(g.edges[curr]);

    if(!visited.includes(curr))
          visited.push(curr);
    if(curr==pass)
          break;
    if(animation==true)
    {
      setTimeout(function() {
            propagater2('div' + curr.slice(1, ));
          }, 10);
      await sleep(11);
      setTimeout(function() {
            propagater('div' + curr.slice(1, ));
          }, 10);
      await sleep(11);
    }
    else {
        propagater('div' + curr.slice(1, ));
    }
    for(const neighbor of g.edges[curr]){

          if(neighbor.weight!=Infinity && !visited.includes(neighbor.node))
          {
            prev[neighbor.node] = curr;

            st.push(neighbor.node);
          }
                }
  }
  st=[];
  st.push(pass);
  prev2=[]
  visited=[];
  while(st.length>0 )
    {
      var curr=st.pop();
      //console.log('see if it is iterable or not');
    //  console.log(g.edges[curr]);

    if(!visited.includes(curr))
          visited.push(curr);
    if(curr==final)
          break;
  if(animation==true)
  {
    setTimeout(function() {
          propagater('div' + curr.slice(1, ));
        }, 10);

    await sleep(11);
    setTimeout(function() {
          propagater2('div' + curr.slice(1, ));
        }, 10);
    await sleep(11);
  }
else {
  propagater2('div' + curr.slice(1, ));
}
    for(const neighbor of g.edges[curr]){

          if(neighbor.weight!=Infinity && !visited.includes(neighbor.node))
          {
            prev2[neighbor.node] = curr;

            st.push(neighbor.node);
          }
                }
  }

  path = [];
  curr = pass;
  console.log('prev1:');
  console.log(prev);
  console.log('prev2:');
  console.log(prev2);
  if (prev[pass] == null) {
      console.log('TARGET CANNOT BE REACHED');
    } else {
      while (prev[curr] != null) {
        path.push(prev[curr]);
        curr = prev[curr];
      }
      path.pop();
    }


    curr = final;
    var path2 = [];
    if (prev2[final] == null) {
      console.log('TARGET CANNOT BE REACHED');
    } else {
      while (prev2[curr] != null) {
        path2.push(prev2[curr]);
        curr = prev2[curr];
      }
      path2.pop();

    }
    /////////////////////
    for (i = 0; i < path.length; i++) {
      path2.push(path[i]);
    }
    path = path2;
    for (i in path) { //console.log(i);
        if(animation==true)
        {
          setTimeout(function() {
            pathhighlighter('div' + path[path.length - i - 1].slice(1, ));
          }, 24);
          await sleep(25);
        }
        else {
          pathhighlighter('div' + path[path.length - i - 1].slice(1, ));

        }


    }

    path = [];

    document.getElementById('div' + start.slice(1, )).style.backgroundColor = 'blue';
    document.getElementById('div' + final.slice(1, )).style.backgroundColor = 'green';

    document.getElementById('div' + pass.slice(1, )).style.backgroundColor = 'orange';
}



}
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=///


async function bidrectional(g,animation=true)
{
    var st1=[];
    var st2=[];
    var visited1=[];
    var visited2=[];
    var intersection;
    st1.push(start);
    st2.push(final);
    console.log('insied bidirecional');
    console.log('st1 length='+st1.length+' and st2= '+st2.length);
    while(st1.length>0 && st2.length>0)
          {
            console.log('inside the while');
            var curr1=st1.shift();
            console.log('curr1='+curr1);


            if(!visited1.includes(curr1))
                {
                  visited1.push(curr1);
                   st1 = st1.filter(i => i !== curr1);
                }
            var curr2=st2.shift();

            if(!visited2.includes(curr2))
                {
                  visited2.push(curr2);
                  st2 = st2.filter(i => i !== curr2);
                }
            console.log('curr1='+curr1+'  and curr2='+curr2);


                if(curr1!='no')
                {
                  if(animation==true)
                    {
                      setTimeout(function() {
                        propagater('div' + curr1.slice(1, ));
                      }, 12);
                    }
                  else {
                      propagater('div' + curr1.slice(1, ));
                  }
                }
                else {
                  await sleep(12);
                }

                if(curr2!='no')
                {
                  if(animation==true)
                    {
                      setTimeout(function() {
                        propagater('div' + curr2.slice(1, ));
                      }, 12);

                    }
                    else {
                        propagater('div' + curr2.slice(1, ));
                    }
                }
                else {
                  await sleep(12);
                }
                if(animation==true)
                await sleep(13);
                if(curr1!='no')
                {
                  if(animation==true)
                    {
                      setTimeout(function() {
                        propagater('div' + curr1.slice(1, ));
                      }, 12);
                    }
                  else {
                      propagater('div' + curr1.slice(1, ));
                  }
                }
                else {
                  await sleep(12);
                }
                if(curr2!='no')
                {
                  if(animation==true)
                    {
                      setTimeout(function() {
                        propagater('div' + curr2.slice(1, ));
                      }, 12);

                    }
                    else {
                        propagater('div' + curr2.slice(1, ));
                    }
                }
                else {
                  await sleep(12);
                }
                if(animation==true)
                await sleep(13);

                console.log('st2=');
                console.log(st2);
                if((visited1.includes(curr2) || visited2.includes(curr1)) && curr1!='no' && curr2!='no')
                    {
                      console.log('intersectino occured at '+curr1);
                      if(visited1.includes(curr2))
                        {
                          intersection=curr2;
                        }
                      else {
                          intersection=curr1;
                      }
                      break;
                    }
            if(curr1!='no')
            {
              for(neighbor of g.edges[curr1])
                  {
                    if(!visited1.includes(neighbor.node))
                    {
                    prev[neighbor.node]=curr1;
                    if(neighbor.weight==1)
                        {
                                  if(st1.indexOf('no')!=-1)
                                    {
                                      st1[st1.indexOf('no')]=neighbor.node;
                                    }
                                  else {
                                    st1.push(neighbor.node);
                                  }
                        }
                    else if(neighbor.weight==5)
                        {
                                  st1.push('no');
                                  st1.push('no');
                                  st1.push('no');
                                  st1.push('no');
                                  st1.push(neighbor.node);

                        }
                    }

                  }
            }



  /////////////////
          if(curr2!='no')
          {

            for(neighbor of g.edges[curr2])
                  {
                      if(!visited2.includes(neighbor.node))
                      {
                        prev2[neighbor.node]=curr2;
                        if(neighbor.weight==1)
                            {
                                      if(st2.indexOf('no')!=-1)
                                        {
                                          st2[st2.indexOf('no')]=neighbor.node;
                                        }
                                      else {
                                        st2.push(neighbor.node);
                                      }
                            }
                        else if(neighbor.weight==5)
                            {
                                      st2.push('no');
                                      st2.push('no');
                                      st2.push('no');
                                      st2.push('no');
                                      st2.push(neighbor.node);

                            }
                      }

                  }

          }
          }
///// path for this algorithm
path=[];
var curr=intersection;
while(prev[curr]!=null)
  {
    path.push(curr);
    curr=prev[curr];
  }
path=path.reverse();
curr=intersection;
while(prev2[curr]!=null)
  {
    path.push(curr);
    curr=prev2[curr];
  }


path=path.reverse();
//////////////////////////
for (i in path) {
    if(animation==true)
    {
      setTimeout(function() {
        pathhighlighter('div' + path[path.length - i - 1].slice(1, ));
      }, 24);

        await sleep(25);
    }
    else {
      pathhighlighter('div' + path[path.length - i - 1].slice(1, ));
    }

}

}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
async function animation_without_pass(animation=true)
      {
        animate=true;
        path=[];

        document.getElementById('div' + start.slice(1, )).style.backgroundColor = 'blue';
        document.getElementById('div' + final.slice(1, )).style.backgroundColor = 'green';


        for (item in distances) {
          if (item.node == start)
            document.getElementById('div' + start.slice(1, )).style.backgroundColor = 'blue';
          else if (item.node == final)
            document.getElementById('div' + final.slice(1, )).style.backgroundColor = 'green';


            if (distances[item][1] != Infinity) {

              if (distances[item][0] != final && distances[item][0] != start)
              if(animation==true)
              {
                  setTimeout(function() {
                    propagater('div' + distances[item][0].slice(1, ));
                  }, 10);
              }
              else {
                propagater('div'+distances[item][0].slice(1, ));
              }

            }
            if(animation==true)
              await sleep(11);

            if (distances[item][0] == final) {
              document.getElementById('div' + distances[item][0].slice(1, )).style.backgroundColor = 'green';
              break;
            }
        }

        document.getElementById('div' + start.slice(1, )).style.backgroundColor = 'blue';
        curr = final;
        if (prev[final] == null) {
          console.log('TARGET CANNOT BE REACHED');
        } else {
          while (prev[curr] != null) {
            path.push(prev[curr]);
            curr = prev[curr];
          }
          path.pop();
        }
        document.getElementById('div' + curr.slice(1, )).style.backgroundColor = 'blue';
        for (i in path) {
          if(animation==true)
          {
            setTimeout(function() {
              pathhighlighter('div' + path[path.length - i - 1].slice(1, ));
            }, 24);
          }
          else {
            pathhighlighter('div' + path[path.length - i - 1].slice(1, ));
          }

          if(animation==true)
          await sleep(25);
        }
      }

//+++++++============================+++++++++++++++++++++++++++++++++++++++//


async function animation_with_pass(animation=true,calculate_all=true)
{
  animate=true;
  check_prev_pass_exist=true;
  document.getElementById('div' + start.slice(1, )).style.backgroundColor = 'blue';
  document.getElementById('div' + final.slice(1, )).style.backgroundColor = 'green';

  document.getElementById('div' + pass.slice(1, )).style.backgroundColor = 'orange';

  for (item in distances) {
    if (distances[item][1] != Infinity) {

        if (distances[item][0] != final && distances[item][0] != start && distances[item][0] != pass)
        if(animation==true)
        {
            setTimeout(function() {
              propagater('div' + distances[item][0].slice(1, ));
            }, 10);
        }
        else {
            propagater('div' + distances[item][0].slice(1, ));
        }


    }
    if(animation==true)
    await sleep(11);


      if (distances[item][0] == pass) {
        document.getElementById('div' + distances[item][0].slice(1, )).style.backgroundColor = 'pink';
        break;
      }

  }

if(calculate_all==true)
{
  for (const item in prev) {
    prev2[item] = prev[item];
  }

  prev = [];
}
if(calculate_all==true)
{
  if(selected_algo=='djkastra')
    distances2 = g.djikstraAlgorithm(pass);
  else if(selected_algo=='A*'){
    distances2=g.A_star(pass,final);
  }
  else if(selected_algo=='bfs')
  {
    distances2=g.bfs(pass);
  }
}

  for (item in distances2) {

      //////////////////////////////////////////////////////////////////////////////////
        if (distances[item][1] != Infinity) {

        if (distances2[item][0] != final && distances2[item][0] != start && distances2[item][0] != pass)
        if(animation==true)
        {

            setTimeout(function() {
              propagater2('div' + distances2[item][0].slice(1, ));
            }, 10);
        }
        else {
          propagater2('div' + distances2[item][0].slice(1, ));
        }
    }
    if(animation==true)
    await sleep(11);


      if (distances2[item][0] == final) {
        document.getElementById('div' + distances2[item][0].slice(1, )).style.backgroundColor = 'pink';
        break;
      }


}


            path = [];
            curr = pass;

            if (prev2[pass] == null) {
                console.log('TARGET CANNOT BE REACHED');
              } else {
                while (prev2[curr] != null) {
                  path.push(prev2[curr]);
                  curr = prev2[curr];
                }
                path.pop();
              }


              curr = final;
              var path2 = [];
              if (prev[final] == null) {
                console.log('TARGET CANNOT BE REACHED');
              } else {
                while (prev[curr] != null) {
                  //    document.getElementById('div'+prev[curr].slice(1,)).style.backgroundColor='#b6eb7a';
                  path2.push(prev[curr]);
                  curr = prev[curr];
                }
                path2.pop();
                //    console.log('this is the path : ');
                //    console.log(path);
              }
              /////////////////////
              for (i = 0; i < path.length; i++) {
                path2.push(path[i]);
              }
              path = path2;
              for (i in path) { //console.log(i);
                if(animation==true)
                {
                  setTimeout(function() {
                    pathhighlighter('div' + path[path.length - i - 1].slice(1, ));
                  }, 24);
                  await sleep(25);
                }
                else {
                  pathhighlighter('div' + path[path.length - i - 1].slice(1, ));
                }
              }

              path = [];

              document.getElementById('div' + start.slice(1, )).style.backgroundColor = 'blue';
              document.getElementById('div' + final.slice(1, )).style.backgroundColor = 'green';

              document.getElementById('div' + pass.slice(1, )).style.backgroundColor = 'orange';

//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

}




//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//

</script>


<script type="text/javascript">
function my1(event)
{
  document.getElementById(event.target.id).style.backgroundColor = 'green';
  selected_algo='djkastra';
  g =graphbuild();
  document.getElementById(event.target.id).style.backgroundColor = 'green';
  document.getElementById('message').innerHTML='Djkistra is used in weighted graph . It always gives Shortest path .(You can use weighted-loks (obstacles) here) ';
  distances = g.djikstraAlgorithm(start);
  if(!pass)
  {

        animation_without_pass(true);
  }
  else {

    animation_with_pass(true,true);
  }

  check_prev_wall = wall.slice();
  check_prev_obstacles=obstacles.slice();

}
function my2(event)
{
    document.getElementById(event.target.id).style.backgroundColor = 'green';
    document.getElementById('message').innerHTML='A* is used in weighted graph. It is faster than djkistra . It always gives Shortest path .(You can use weighted-loks (obstacles) here) ';
    selected_algo='A*';
    g=graphbuild();
    if(!pass)
    {
        distances=g.A_star(start,final);
        animation_without_pass(true);
    }
    else {
      distances=g.A_star(start,pass);
      animation_with_pass(true,true);
    }
    check_prev_wall = wall.slice();
    check_prev_obstacles=obstacles.slice();
}


function my3(event)
{

  document.getElementById(event.target.id).style.backgroundColor = 'green';
  selected_algo='bfs';
  animate=true;
  document.getElementById(event.target.id).style.backgroundColor = 'green';
  document.getElementById('message').innerHTML='BFS is used for trvaersal in unweighted graph. So weighted-locks (obstacles) are not available';
  console.log('-----------------------obs');
  console.log(obstacles);
  console.log('obstacle length: '+obstacles.length);
  for(i in obstacles)
  {
    document.getElementById('div'+obstacles[i].slice(1,)).classList.remove("fa","fa-lock");
    console.log(i);
  }
  obstacles=[];
    g =graphbuild();
  distances = g.bfs(start);
  if(!pass)
  {

        animation_without_pass(true);
  }
  else {

    animation_with_pass(true,true);
  }

  check_prev_wall = wall.slice();
  check_prev_obstacles=obstacles.slice();

}

function my4(event){
  document.getElementById(event.target.id).style.backgroundColor = 'green';
  document.getElementById('message').innerHTML ="DFS is used in unweighted graph and it is not meant for shortest path.";
  selected_algo='dfs';
  animate=true;
  for(i in obstacles)
  {
    document.getElementById('div'+obstacles[i].slice(1,)).classList.remove("fa","fa-lock");
  }
  obstacles=[];
  g=graphbuild();
  dfs(g,start,true);
}
function my5(event)
  {
    animate=true;
    document.getElementById(event.target.id).style.backgroundColor = 'green';
    document.getElementById('message').innerHTML ="bidrectional tries to find shortest path by propagating from both final and start node till the intersectionoccures . It does not give shortest path.";
    selected_algo='bidrectional';
    g=graphbuild();
    bidrectional(g,true);


  }

</script>

<!-- for drag and drop of start point ,pass point and end point -->


<script>
  var dragImg;

  function stick(event) {


    dragImg = event.target;

    dragImg.addEventListener("mousedown", function(event) {
      event.stopPropagation();
      dragImg = event.target;
      //  console.log("mousedown detected " + dragImg.clientHeight);
      dragImg.setAttribute("class", "drag");
      imagedragging = true;
      //  console.log('imagedragging is set true');
    });

    document.addEventListener("mousemove", function(event) {
      if (imagedragging) {
        //  console.log('mouse move and imagedragging is '+imagedragging);
        dragImg.style.top = (event.clientY - dragImg.clientHeight / 2) + "px";
        dragImg.style.left = (event.clientX - dragImg.clientWidth / 2) + "px";
      }
    });

    document.body.addEventListener("mouseup", function(event) {
      if (imagedragging) {
        //  console.log("mouseup detected");

        //reset position if not in clipboard
        dragImg.removeAttribute("class");
        //  console.log(dragImg.id+' here mouse is lifted at'+event.target.id);
        //  console.log('imagedragging='+imagedragging+'   and animate='+animate);
        if (event.target.id.slice(0, 3) == 'div')
          document.getElementById(event.target.id).style.backgroundColor = 'orange';
        if (dragImg.id == 'start') {
          start = 'b' + event.target.id.slice(3, );
          document.getElementById(event.target.id).style.backgroundColor = 'blue';
        } else if (dragImg.id == 'end') {
          final = 'b' + event.target.id.slice(3, );
          document.getElementById(event.target.id).style.backgroundColor = 'green';
        } else if (dragImg.id == 'pass') {
          pass = 'b' + event.target.id.slice(3, );
          document.getElementById(event.target.id).style.backgroundColor = 'orange';
        }
        dragImg.style.top = (event.clientY - dragImg.clientHeight / 2) + "px";
        dragImg.style.left = (event.clientX - dragImg.clientWidth / 2) + "px";

        dragImg = null;
        imagedragging = false;
        //console.log('imagedragging false');
      }
    });



  }
</script>



<!-- //////////////////////  this is war wall   //////////////////////////////// -->
<script type="text/javascript">
  function mousedown(e) {

    var b_id = 'b' + e.target.id.slice(3, );
    if (e.button == 0 && (!imagedragging)) {
      lclicked = true;
      if (!wall.includes('b' + e.target.id.slice(3, )) && e.target.id.slice(0, 3) == 'div') {
        if ('b' + e.target.id.slice(3, ) != start && 'b' + e.target.id.slice(3, ) != final) {

          //    console.log('entering s='+start+' f='+final+'  curr='+'b'+e.target.id.slice(3,));
          document.getElementById(e.target.id).style.backgroundColor = 'black';
          wall.push('b' + e.target.id.slice(3, ));
          console.log('b' + e.target.id.slice(3, ) + '  has been push to the wall');
        }
      }
    }
    else if(e.button==1 && (!imagedragging) && (selected_algo!='bfs') && (selected_algo!='dfs'))
    {
      middleclicked = true;
      console.log('entered in {}}}}}}}{}}}}}}}}}}}} with '+selected_algo+ ' and e.button as '+e.button);
      if (!obstacles.includes('b' + e.target.id.slice(3, )) && e.target.id.slice(0, 3) == 'div') {

          //    console.log('entering s='+start+' f='+final+'  curr='+'b'+e.target.id.slice(3,));
          var element=document.getElementById(e.target.id)
          element.classList.add("fa","fa-lock");
          obstacles.push('b' + e.target.id.slice(3, ));
          console.log('b' + e.target.id.slice(3, ) + '  has been push to the obstacles');

      }

    }
    else if (e.button == 2 ) {
      rclicked = true;
      e.preventDefault();
      if (wall.includes('b' + e.target.id.slice(3, ))) {
        document.getElementById(e.target.id).style.backgroundColor = 'white';
        var ind = wall.indexOf('b' + e.target.id.slice(3, ));
        if (ind > -1) {
          wall.splice(ind, 1);
        }
      }
      if (obstacles.includes('b' + e.target.id.slice(3, ))) {
        document.getElementById(e.target.id).classList.remove("fa","fa-lock");
        var ind = obstacles.indexOf('b' + e.target.id.slice(3, ));
        if (ind > -1) {
          obstacles.splice(ind, 1);
        }
      }

    }
  }

  function mouseup(e) {
    if (e.button == 0) {
      lclicked = false;
    }
    if (e.button == 2) {
      e.preventDefault();
      rclicked = false;
    }
    if(e.button == 1 && (selected_algo!='bfs' || selected_algo!='dfs'))
    {
      e.preventDefault();
      middleclicked=false;
    }
  }

  function entering(e) {
    //  console.log('entering+ '+e.target.id+'with animate='+animate +" and imagedragging="+imagedragging);
    var b_id = 'b' + e.target.id.slice(3, );
    if (lclicked == true && (!imagedragging) && e.target.id.slice(0, 3) == 'div') {
      if (!wall.includes(b_id)) {
        if (b_id != start && b_id != final && b_id != pass) {
          //        console.log('entering s='+start+' f='+final+'  curr='+b_id);
          wall.push(b_id);
          console.log(b_id + ' has been pushed to the wall');
          document.getElementById(e.target.id).style.backgroundColor = 'black';


        }
      }
    }
    else if(middleclicked == true && (!imagedragging) && (selected_algo!='bfs' || selected_algo!='dfs'))
    {
      e.preventDefault();
      if (!obstacles.includes(b_id)) {
          obstacles.push(b_id);
          console.log(b_id + ' has been pushed to the obstacles');
          var element=document.getElementById(e.target.id)
          element.classList.add("fa","fa-lock");
      }
    }
    else if (rclicked == true && (!imagedragging)) {
      e.preventDefault();
      if (wall.includes(b_id)) {
        var ind = wall.indexOf(b_id);
        if (ind > -1) {
          wall.splice(ind, 1);
        }
        document.getElementById(e.target.id).style.backgroundColor = 'white';
        //      console.log(wall);
      }
      if(obstacles.includes(b_id))
      {
        var ind = obstacles.indexOf(b_id);
      if (ind > -1) {
        obstacles.splice(ind, 1);
      }
      console.log('we are trying to remove lock of '+e.target.id);
      document.getElementById(e.target.id).classList.remove("fa","fa-lock");


      }
    } else if (animate && imagedragging) {
      //  console.log('mosue has eneterd while dragging in '+e.target.id);
      //    document.getElementById(e.target.id).style.backgroundColor='purple';
      if (dragImg.id == 'end') {
                  console.log('  final is being dragged');
                  final = 'b' + e.target.id.slice(3, );
                  if(selected_algo=='A*')
                              {
                                        console.log('A* entering triggered');
                                        g=graphbuild();
                                        if(!pass)
                                            {
                                              distances=g.A_star(start,final);
                                              animation_without_pass(false);
                                            }
                                        else
                                            {
                                            distances=g.A_star(start,pass);
                                            animation_with_pass(false,true);
                                            }
                              }
                  else if(selected_algo=='djkastra')
                              {
                                      graphbuild();
                                      if(pass)
                                        {
                                            if(arraysEqual(wall,check_prev_wall) && arraysEqual(obstacles,check_prev_obstacles))
                                              {
                                                animation_with_pass(false,false);
                                                path=[];
                                                path2=[];

                                              }
                                              else {
                                                  g=graphbuild();
                                                  distances=g.djikstraAlgorithm(start);
                                                  animation_with_pass(false,true);
                                                  check_prev_wall=wall.slice();
                                                  check_prev_obstacles=obstacles.slice();
                                              }


                                        }
                                        else {

                                            if(arraysEqual(wall,check_prev_wall) && arraysEqual(obstacles,check_prev_obstacles))
                                            {
                                                animation_without_pass(false);
                                            }
                                            else {
                                                g=graphbuild();
                                                distances=g.djikstraAlgorithm(start);
                                                animation_without_pass(false);
                                                check_prev_wall=wall.slice();
                                                check_prev_obstacles=obstacles.slice();
                                            }

                                        }
                              }
                            else if(selected_algo=='bfs')
                                {
                                  obstacles=[];
                                  graphbuild();
                                  if(pass)
                                    {
                                        if(arraysEqual(wall,check_prev_wall) && arraysEqual(obstacles,check_prev_obstacles))
                                          {
                                            animation_with_pass(false,false);
                                            path=[];
                                            path2=[];

                                          }
                                          else {
                                              g=graphbuild();
                                              distances=g.bfs(start);
                                              animation_with_pass(false,true);
                                              check_prev_wall=wall.slice();
                                              check_prev_obstacles=obstacles.slice();
                                          }


                                    }
                                    else {

                                        if(arraysEqual(wall,check_prev_wall) && arraysEqual(obstacles,check_prev_obstacles))
                                        {
                                            animation_without_pass(false);
                                        }
                                        else {
                                            g=graphbuild();
                                            distances=g.bfs(start);
                                            animation_without_pass(false);
                                            check_prev_wall=wall.slice();
                                            check_prev_obstacles=obstacles.slice();
                                        }
                                    }
                                }
                            else if(selected_algo=='dfs')
                            {

                              for(i in obstacles)
                              {
                                document.getElementById('div'+obstacles[i].slice(1,)).classList.remove("fa","fa-lock");
                              }
                              obstacles=[];
                              g=graphbuild();
                              dfs(g,start,false);

                            }
                            else if(selected_algo=='bidrectional')
                             {console.log('YYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY');
                              g=graphbuild();
                              bidrectional(g,false);
                            }
      }
    //end of end image dragging
    else if(dragImg.id=='pass')
      {
        pass = 'b' + e.target.id.slice(3, );
        if(selected_algo=='A*')
          {
            g=graphbuild();
            distances=g.A_star(start,pass);
            animation_with_pass(false,true);


          }
        else if(selected_algo=='djkastra') {

              if(check_prev_pass_exist)
              {
                  if(arraysEqual(check_prev_wall,wall) && arraysEqual(obstacles,check_prev_obstacles))
                    {
                        console.log('|||||||||||||||||||');
                        g=graphbuild();
                        distances=g.djikstraAlgorithm(start);
                        animation_with_pass(false,true);
                    }
                  else {
                        g=graphbuild();
                        distances=g.djikstraAlgorithm(start);
                        animation_with_pass(false,true);
                        check_prev_wall=wall.slice();
                        check_prev_obstacles=obstacles.slice();
                  }
              }
              else {
                g=graphbuild();
                distances=g.djikstraAlgorithm(start);
                animation_with_pass(false,true);
                check_prev_wall=wall.slice();
                check_prev_obstacles=obstacles.slice();
              }
        }
        else if(selected_algo=='bfs')
              {
                if(check_prev_pass_exist)
                {
                    if(arraysEqual(check_prev_wall,wall) && arraysEqual(obstacles,check_prev_obstacles))
                      {
                          console.log('|||||||||||||||||||');
                          g=graphbuild();
                          distances=g.bfs(start);
                          animation_with_pass(false,true);
                      }
                    else {
                          g=graphbuild();
                          distances=g.bfs(start);
                          animation_with_pass(false,true);
                          check_prev_wall=wall.slice();
                          check_prev_obstacles=obstacles.slice();
                    }
                }
                else {
                  g=graphbuild();
                  distances=g.bfs(start);
                  animation_with_pass(false,true);
                  check_prev_wall=wall.slice();
                  check_prev_obstacles=obstacles.slice();
                }
              }
              else if(selected_algo=='dfs')
              {
                for(i in obstacles)
                {
                  document.getElementById('div'+obstacles[i].slice(1,)).classList.remove("fa","fa-lock");
                }
                obstacles=[];
                g=graphbuild();
                dfs(g,start,false);
              }
              else if(selected_algo=='bidrectional') {
                g=graphbuild();
                bidrectional(g,false);
              }
      }  //end of pass image draging
    else if (dragImg.id=='start')
    {

        start = 'b' + e.target.id.slice(3, );
      console.log('start is being dragged');
      if(selected_algo=='A*')
        {
          g=graphbuild();

          if(!pass)
              {

                  distances=g.A_star(start,final);
                  animation_without_pass(false);
              }
          else {
              console.log('?????????????????');
            distances=g.A_star(start,pass);
            animation_with_pass(false,true);
          }
        }
      else if(selected_algo=='djkastra')
        {

          g=graphbuild();
          distances=g.djikstraAlgorithm(start);
          if(!pass)
            animation_without_pass(false);
          else {
            animation_with_pass(false,true);
          }
        }
      else if(selected_algo=='bfs')
        {
          g=graphbuild();
          distances=g.bfs(start);
          if(!pass)
            animation_without_pass(false);
          else {
            animation_with_pass(false,true);
          }
        }
        else if(selected_algo=='dfs')
        {
          for(i in obstacles)
          {
            document.getElementById('div'+obstacles[i].slice(1,)).classList.remove("fa","fa-lock");
          }
          obstacles=[];

          g=graphbuild();
          dfs(g,start,false);
        }
        else if(selected_algo=='bidrectional') {
          g=graphbuild();
          bidrectional(g,false);
        }
    }
  }

}
</script>

<!-- prevernting the right click default of the google chrome -->

<script type="text/javascript">
  document.getElementById('graph').addEventListener('contextmenu', function(evt) {
    evt.preventDefault();
  }, false);
</script>




</html>
