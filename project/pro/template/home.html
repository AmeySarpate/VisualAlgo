{% load static %}
<!DOCTYPE html>
<html lang="en" dir="ltr">

<head>
  <meta charset="utf-8">
  <title></title>
  <link rel="stylesheet" href="{% static 'css/s.css'%}">
  <style media="screen">
  .fa
  {
    text-align: center;

  }
  </style>
</head>

<body>

  <ul>
    <li><button id='nav1' onclick="my1(event)">Djkastra</button></li>
    <li><button id='nav2' onclick="my2(event)">A* algorithm</button></li>
    <li><button id='nav3' onclick="my3(event)">3rd algo</button></li>
    <center style='float:right'>
      <li><button id='nav4' onclick='myFunction2(event)'>Visualize</button></li>
    </center>

  </ul>

  <img id='start' src="{% static 'images/start.png'%}" alt="Photo" width='14px' height='14px' style='margin:0;left:30px;' onclick='stick(event)'>
  <img id='end' src="{% static 'images/end.png'%}" alt="Photo" width='14px' height='14px' style='margin:0;left:60px;' onclick='stick(event)'>
  <img id='pass' src="{% static 'images/pass.png'%}" alt="Photo" width='14px' height='14px' style='margin:0;left:90px;' onclick='stick(event)'>
  <br>
  <div id='graph' unselectable="on" onselectstart="return false;">
    <table style="width:100%">
      {% for row in rows%}
      <tr>


        {% for col in cols %}
        <td id='b_{{row}}_{{col}}' style="width:15px;height:15px;padding-right:0px;margin:0px;">

          <div id="div_{{row}}_{{col}}" style='margin:0px;width:23.8px;height:21.8px;display:block;' onmouseenter='entering(event)' onmousedown="mousedown(event)" onmouseup="mouseup(event)"></div>

        </td>
        {%endfor%}
      </tr>
      {% endfor%}
    </table>

  </div>

</body>

<!--varible declaration and initials-->
<script src="https://use.fontawesome.com/a016dd128e.js"></script>
<script type="text/javascript">
  var start;
  var final;
  var pass;
  var lclicked;
  var rclicked;
  var wall = [];
  var imagedragging = false;
  var path = [];
  var path2 = [];
  var prev = [];
  var prev2 = [];
  var selected_algo;
  var distances = [];
  var middleclicked=false;
  var check_prev_wall = [];
  var obstacles=[];
  var check_prev_obstacles=[];
  var check_prev_pass_exist=false;
  var animate = false;
  var g;

  var x = document.querySelectorAll("div");
  for (i = 1; i < x.length; i++) {
    x[i].style.backgroundColor = "white";
  }
</script>

<!-- class declaration -->
<script type="text/javascript">
  class Graph {
    constructor() {
      this.edges = {};
      this.nodes = [];
    }
    addNode(node) {
      this.nodes.push(node);
      this.edges[node] = [];
    }
    addEdge(node1, node2) {
      this.edges[node1].push(node2);
      this.edges[node2].push(node1);
    }

    addDirectedEdge(node1, node2, weight = 1) {
      this.edges[node1].push({
        node: node2,
        weight: weight
      });
    }

    display() {
      let graph = "";
      this.nodes.forEach(node => {
        graph += node + "->" + this.edges[node].join(", ") + "\n";
      });
      //    console.log(graph);
    }
    djikstraAlgorithm(startNode) {
      let distances = {};

      // Stores the reference to previous nodes

      let pq = new PriorityQueue(this.nodes.length * this.nodes.length);

      // Set distances to all nodes to be infinite except startNode
      distances[startNode] = 0;
      pq.enqueue(startNode, 0);
      this.nodes.forEach(node => {
        if (node !== startNode) distances[node] = Infinity;
        prev[node] = null;
      });

      while (!pq.isEmpty()) {
        let minNode = pq.dequeue();
        let currNode = minNode.data;
        let weight = minNode.priority;
        this.edges[currNode].forEach(neighbor => {
          let alt = distances[currNode] + neighbor.weight;
          if (alt < distances[neighbor.node]) {
            distances[neighbor.node] = alt;
            prev[neighbor.node] = currNode;
            pq.enqueue(neighbor.node, distances[neighbor.node]);
          }
        });
      }

      var sortable = [];
      for (var n in distances) {
        sortable.push([n, distances[n]]);
      }
      sortable.sort(function(a, b) {
        return a[1] - b[1];
      });
      return sortable;
    }

//this is A* algorithm
    A_star(startNode,endNode)
      {

        let distances = {};
        let pred_distances={};
        // Stores the reference to previous nodes
        let final_i=endNode.split("_")[1];
        let final_j=endNode.split("_")[2];
        let pq = new PriorityQueue(this.nodes.length * this.nodes.length);

        for(let i=1;i<={{nrows}};i++)
          {
            for(let j=1;j<={{ncols}};j++)
              {
                pred_distances['b_'+i+'_'+j]=abs(final_j-j)+abs(final_i-i);
              }
          }
        // Set distances to all nodes to be infinite except startNode
        distances[startNode] = 0;
        pq.enqueue(startNode, 0);
        this.nodes.forEach(node => {
          if (node !== startNode) distances[node] = Infinity;
          prev[node] = null;
        });

        while (!pq.isEmpty()) {
          let minNode = pq.dequeue();
          let currNode = minNode.data;
          let weight = minNode.priority;
          this.edges[currNode].forEach(neighbor => {
            let alt = distances[currNode] + neighbor.weight;
            if (alt < distances[neighbor.node]) {
              distances[neighbor.node] = alt;
              prev[neighbor.node] = currNode;
              pq.enqueue(neighbor.node, distances[neighbor.node]);
            }
          });
        }

        var sortable = [];
        for (var n in distances) {
          sortable.push([n, distances[n]+pred_distances[n],distances[n]]);
        }

        sortable.sort(function(a,b){
              if(a[1]<b[1])
              {
                return a[1]-b[1];
              }
              else if(a[1]==b[1])
              {
                return a[2]-b[2];
              }
              else {
                return a[1]-b[1];
              }
        }
      );
        return sortable;


      }
    breadth_first_search(startNode,finalNode)
    {
      var visited=[];
      var dist={};
      var pre={};
      var queue=new Queue();
  //    console.log('--------------------------------------------------(9999999999999999)');
      queue.enqueue(startNode);
      this.nodes.forEach(node => {
        if (node !== startNode) dist[node] = Infinity;
        pre[node] = null;
      });
      var curr=startNode;
      dist[startNode]=0;
      while(!queue.isEmpty())
        {

          curr=queue.dequeue();
          if(curr==finalNode)
              break;
          document.getElementById('div'+curr.slice(1,)).style.backgroundColor='pink';
          console.log('1---> '+curr+' is removed');
          if(!visited.includes(curr))
          {
          visited.push(curr);
          this.edges[curr].forEach(neighbor =>{
            if(neighbor.weight!=Infinity && (!visited.includes(neighbor.node)))
            {
              console.log('22--->'+neighbor.node+' is added as neighbor');
              console.log('visited list is '+visited);
              queue.enqueue(neighbor.node);
              pre[neighbor.node]=curr;
            }

          });
        }
        }
        path=[];
        curr = finalNode;
        if (pre[finalNode] == null) {
          console.log('TARGET CANNOT BE REACHED');
        } else {
          while (pre[curr] != null) {
            path.push(pre[curr]);
            curr = pre[curr];
          }
          path.pop();
        }
        document.getElementById('div' + curr.slice(1, )).style.backgroundColor = 'blue';
        for (i in path) {
            pathhighlighter('div' + path[path.length - i - 1].slice(1, ));
        }



  }
}
/////////////////////////
class Queue {
   constructor(maxSize) {
      // Set default max size if not provided
      if (isNaN(maxSize)) {
         maxSize = 2000;
      }
      this.maxSize = maxSize;
      // Init an array that'll contain the queue values.
      this.container = [];
    }
   // Helper function to display all values while developing
   display() {
      console.log(this.container);
   }
   // Checks if queue is empty
   isEmpty() {
      return this.container.length === 0;
   }
   // checks if queue is full
   isFull() {
      return this.container.length >= this.maxSize;
   }
   enqueue(element) {
      // Check if Queue is full
      if (this.isFull()) {
         console.log("Queue Overflow!"); return;
      }
      // Since we want to add elements to end, we'll just push them.
      this.container.push(element);
   }
   dequeue() {
      // Check if empty
      if (this.isEmpty()) {
         console.log("Queue Underflow!");
         return;
      }
      return this.container.shift();
   }
   peek() {
      if (this.isEmpty()) {
         console.log("Queue Underflow!");
         return;
      }
      return this.container[0];
   }
   clear() {
      this.container = [];
   }
}



////////////////////
  class PriorityQueue {
    constructor(maxSize) {
      // Set default max size if not provided
      if (isNaN(maxSize)) {
        maxSize = 100;
      }
      this.maxSize = maxSize;
      // Init an array that'll contain the queue values.
      this.container = [];
    }
    // Helper function to display all values while developing
    display() {
      //    console.log(this.container);
    }
    // Checks if queue is empty
    isEmpty() {
      return this.container.length === 0;
    }
    // checks if queue is full
    isFull() {
      return this.container.length >= this.maxSize;
    }
    enqueue(data, priority) {
      // Check if Queue is full
      if (this.isFull()) {
        console.log("Queue Overflow!");
        return;
      }
      let currElem = new this.Element(data, priority);
      let addedFlag = false;
      // Since we want to add elements to end, we'll just push them.
      for (let i = 0; i < this.container.length; i++) {
        if (currElem.priority < this.container[i].priority) {
          this.container.splice(i, 0, currElem);
          addedFlag = true;
          break;
        }
      }
      if (!addedFlag) {
        this.container.push(currElem);
      }
    }
    dequeue() {
      // Check if empty
      if (this.isEmpty()) {
        console.log("Queue Underflow!");
        return;
      }
      return this.container.pop();
    }
    peek() {
      if (isEmpty()) {
        console.log("Queue Underflow!");
        return;
      }
      return this.container[this.container.length - 1];
    }
    clear() {
      this.container = [];
    }
  }


  PriorityQueue.prototype.Element = class {
    constructor(data, priority) {
      this.data = data;
      this.priority = priority;
    }
  };
</script>

<!-- path propagater and highlighter functions -->
<script type="text/javascript">
  function arraysEqual(a, b) {
    if (a === b) return true;
    if (a == null || b == null) return false;
    if (a.length !== b.length) return false;

    // If you don't care about the order of the elements inside
    // the array, you should sort both arrays here.
    // Please note that calling sort on an array will modify that array.
    // you might want to clone your array first.

    for (var i = 0; i < a.length; ++i) {
      if (a[i] !== b[i]) return false;
    }
    return true;
  }
  function abs(x){
    if(x>0)
      return x;
    else
    return -x;
  }


  function pathhighlighter(id) {
    if (id != start) {
      document.getElementById(id).style.backgroundColor = 'yellow';
      document.getElementById('b' + id.slice(3, )).style.border = "0px solid yellow";
      document.getElementById('b' + id.slice(3, )).style.margin = "0px";
    }
  }

  function propagater(id) {
    if (id != start && id != pass && id != final) {
      //  console.log(id +'is going to propagate');
      document.getElementById(id).style.backgroundColor = '#a6dcef';
      document.getElementById('b' + id.slice(3, )).style.border = "0px solid #a6dcef";
      document.getElementById('b' + id.slice(3, )).style.margin = "0px";
    }
  }

  function propagater2(id) {
    //  console.log('------------------------------'+id+'---------------------------');
    if (id != start && id != final && id != pass) {
      document.getElementById(id).style.backgroundColor = 'pink';
      document.getElementById('b' + id.slice(3, )).style.border = "0px solid pink";
      document.getElementById('b' + id.slice(3, )).style.margin = "0px";
    }
  }
</script>


sleep function
<script type="text/javascript">
  function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
</script>

<!-- other very important breaked function  -->
<script type="text/javascript">
  function graphbuild() {

    var x = document.querySelectorAll("div");
    for (i = 1; i < x.length; i++) {
      x[i].style.backgroundColor = "white";
    }
    var k = document.querySelectorAll('td');
    for (i = 1; i < k.length; i++) {
      k[i].style.border = "1px solid black";
    }
    let g = new Graph();
    for(let i=1;i<={{nrows}};i++)
  {
  for(let j=1;j<={{ncols}};j++)
    {
    g.addNode('b_'+i+'_'+j);
    }
  }


  for(let i=1;i<={{nrows}};i++)
    {
    for(let j=1;j<={{ncols}}-1;j++)
      {
      g.addDirectedEdge('b_'+i+'_'+j,'b_'+i+'_'+(j+1),1);
      g.addDirectedEdge('b_'+i+'_'+(j+1),'b_'+i+'_'+j,1);

      }
    }
    for(let i=1;i<={{ncols}};i++)
      {
      for(let j=1;j<={{nrows}}-1;j++)
        {
        g.addDirectedEdge('b_'+j+'_'+i,'b_'+(j+1)+'_'+(i),1);
        g.addDirectedEdge('b_'+(j+1)+'_'+(i),'b_'+j+'_'+i,1);
        }
      }


    for (item in wall) {
      document.getElementById('div' + wall[item].slice(1, )).style.backgroundColor = 'black';
      nearest = g.edges[wall[item]];
      for (i in nearest) {
        nearest[i].weight = Infinity;


      }

    }
    for(item in obstacles)
    {
      var element=document.getElementById('div' + obstacles[item].slice(1, ))
      element.classList.add("fa","fa-lock");
      nearest = g.edges[obstacles[item]];
      for (i in nearest) {
        nearest[i].weight = 5;
      }
    }
    for (k in g.edges) {
      for (t in g.edges[k]) {
        if (obstacles.includes(g.edges[k][t].node)) {
          g.edges[k][t].weight = 5;

        }
      }


    }
    for (k in g.edges) {
      for (t in g.edges[k]) {
        if (wall.includes(g.edges[k][t].node)) {
          g.edges[k][t].weight = Infinity;

        }
      }


    }
    return g;
  }

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
async function animation_without_pass(animation=true)
      {
        animate=true;
        path=[];

        document.getElementById('div' + start.slice(1, )).style.backgroundColor = 'blue';
        document.getElementById('div' + final.slice(1, )).style.backgroundColor = 'green';


        for (item in distances) {
          if (item.node == start)
            document.getElementById('div' + start.slice(1, )).style.backgroundColor = 'blue';
          else if (item.node == final)
            document.getElementById('div' + final.slice(1, )).style.backgroundColor = 'green';


            if (distances[item][1] != Infinity) {

              if (distances[item][0] != final && distances[item][0] != start)
              if(animation==true)
              {
                  setTimeout(function() {
                    propagater('div' + distances[item][0].slice(1, ));
                  }, 10);
              }
              else {
                propagater('div'+distances[item][0].slice(1, ));
              }

            }
            if(animation==true)
              await sleep(11);

            if (distances[item][0] == final) {
              document.getElementById('div' + distances[item][0].slice(1, )).style.backgroundColor = 'green';
              break;
            }
        }

        document.getElementById('div' + start.slice(1, )).style.backgroundColor = 'blue';
        curr = final;
        if (prev[final] == null) {
          console.log('TARGET CANNOT BE REACHED');
        } else {
          while (prev[curr] != null) {
            path.push(prev[curr]);
            curr = prev[curr];
          }
          path.pop();
        }
        document.getElementById('div' + curr.slice(1, )).style.backgroundColor = 'blue';
        for (i in path) {
          if(animation==true)
          {
            setTimeout(function() {
              pathhighlighter('div' + path[path.length - i - 1].slice(1, ));
            }, 24);
          }
          else {
            pathhighlighter('div' + path[path.length - i - 1].slice(1, ));
          }

          if(animation==true)
          await sleep(25);
        }
      }

//+++++++============================+++++++++++++++++++++++++++++++++++++++//


async function animation_with_pass(animation=true,calculate_all=true)
{
  animate=true;
  check_prev_pass_exist=true;
  document.getElementById('div' + start.slice(1, )).style.backgroundColor = 'blue';
  document.getElementById('div' + final.slice(1, )).style.backgroundColor = 'green';

  document.getElementById('div' + pass.slice(1, )).style.backgroundColor = 'orange';

  for (item in distances) {
    if (distances[item][1] != Infinity) {

        if (distances[item][0] != final && distances[item][0] != start && distances[item][0] != pass)
        if(animation==true)
        {
            setTimeout(function() {
              propagater('div' + distances[item][0].slice(1, ));
            }, 10);
        }
        else {
            propagater('div' + distances[item][0].slice(1, ));
        }


    }
    if(animation==true)
    await sleep(11);


      if (distances[item][0] == pass) {
        document.getElementById('div' + distances[item][0].slice(1, )).style.backgroundColor = 'pink';
        break;
      }

  }
  // curr = pass;
  // if (prev[pass] == null) {
  //   console.log('TARGET CANNOT BE REACHED');
  // } else {
  //   while (prev[curr] != null) {
  //     path.push(prev[curr]);
  //     curr = prev[curr];
  //   }
  //   path.pop();
  //
  // }
if(calculate_all==true)
{
  for (const item in prev) {
    prev2[item] = prev[item];
  }

  prev = [];
}
if(calculate_all==true)
{
  if(selected_algo=='djkastra')
    distances2 = g.djikstraAlgorithm(pass);
  else if(selected_algo=='A*'){
    distances2=g.A_star(pass,final);
  }
}

  for (item in distances2) {

      //////////////////////////////////////////////////////////////////////////////////
        if (distances[item][1] != Infinity) {

        if (distances2[item][0] != final && distances2[item][0] != start && distances2[item][0] != pass)
        if(animation==true)
        {

            setTimeout(function() {
              propagater2('div' + distances2[item][0].slice(1, ));
            }, 10);
        }
        else {
          propagater2('div' + distances2[item][0].slice(1, ));
        }
    }
    if(animation==true)
    await sleep(11);


      if (distances2[item][0] == final) {
        document.getElementById('div' + distances2[item][0].slice(1, )).style.backgroundColor = 'pink';
        break;
      }


}


  // curr = final;
  // var path2 = [];
  // if (prev[final] == null) {
  //   console.log('TARGET CANNOT BE REACHED');
  // } else {
  //   while (prev[curr] != null) {
  //     path2.push(prev[curr]);
  //     curr = prev[curr];
  //   }
  //   path2.pop();
  // }
  // for (i = 0; i < path.length; i++) {
  //   path2.push(path[i]);
  // }
  // path = path2;
  // for (i in path) {
    // if(animation==true)
    // {
    //   setTimeout(function() {
    //     pathhighlighter('div' + path[path.length - i - 1].slice(1, ));
    //   }, 24);
    //   await sleep(25);
    // }
    // else {
    //   pathhighlighter('div' + path[path.length - i - 1].slice(1, ));
    // }
  //
  // }
  //
  // path = [];
  // document.getElementById('div' + start.slice(1, )).style.backgroundColor = 'blue';
  // document.getElementById('div' + final.slice(1, )).style.backgroundColor = 'green';
  //
  // document.getElementById('div' + pass.slice(1, )).style.backgroundColor = 'orange';
//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
            path = [];
            curr = pass;

            if (prev2[pass] == null) {
                console.log('TARGET CANNOT BE REACHED');
              } else {
                while (prev2[curr] != null) {
                  //    document.getElementById('div'+prev[curr].slice(1,)).style.backgroundColor='#b6eb7a';
                  path.push(prev2[curr]);
                  curr = prev2[curr];
                }
                path.pop();
                //    console.log('this is the path : ');
                //    console.log(path);
              }


              curr = final;
              var path2 = [];
              if (prev[final] == null) {
                console.log('TARGET CANNOT BE REACHED');
              } else {
                while (prev[curr] != null) {
                  //    document.getElementById('div'+prev[curr].slice(1,)).style.backgroundColor='#b6eb7a';
                  path2.push(prev[curr]);
                  curr = prev[curr];
                }
                path2.pop();
                //    console.log('this is the path : ');
                //    console.log(path);
              }
              /////////////////////
              for (i = 0; i < path.length; i++) {
                path2.push(path[i]);
              }
              path = path2;
              for (i in path) { //console.log(i);
                if(animation==true)
                {
                  setTimeout(function() {
                    pathhighlighter('div' + path[path.length - i - 1].slice(1, ));
                  }, 24);
                  await sleep(25);
                }
                else {
                  pathhighlighter('div' + path[path.length - i - 1].slice(1, ));
                }
              }

              path = [];

              document.getElementById('div' + start.slice(1, )).style.backgroundColor = 'blue';
              document.getElementById('div' + final.slice(1, )).style.backgroundColor = 'green';

              document.getElementById('div' + pass.slice(1, )).style.backgroundColor = 'orange';

//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

}




//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//

</script>


<script type="text/javascript">
function my1(event)
{
  document.getElementById(event.target.id).style.backgroundColor = 'green';
  selected_algo='djkastra';
  g =graphbuild();
  document.getElementById(event.target.id).style.backgroundColor = 'green';

  distances = g.djikstraAlgorithm(start);
  if(!pass)
  {

        animation_without_pass(true);
  }
  else {

    animation_with_pass(true,true);
  }

  check_prev_wall = wall.slice();
  check_prev_obstacles=obstacles.slice();

}
function my2(event)
{
    document.getElementById(event.target.id).style.backgroundColor = 'green';
    selected_algo='A*';
    g=graphbuild();
    if(!pass)
    {
        distances=g.A_star(start,final);
        animation_without_pass(true);
    }
    else {
      distances=g.A_star(start,pass);
      animation_with_pass(true,true);
    }
    check_prev_wall = wall.slice();
    check_prev_obstacles=obstacles.slice();
}


function my3(event)
{


    document.getElementById(event.target.id).style.backgroundColor='green';
    selected_algo='bfs';
    g=graphbuild();
      console.log('this is the length: '+({{nrows}}*{{ncols}}));
    g.breadth_first_search(start,final);






}

  function myFunction2(event) {

    return 2+5;
  }
</script>

<!-- for drag and drop of start point ,pass point and end point -->


<script>
  var dragImg;

  function stick(event) {


    dragImg = event.target;

    dragImg.addEventListener("mousedown", function(event) {
      event.stopPropagation();
      dragImg = event.target;
      //  console.log("mousedown detected " + dragImg.clientHeight);
      dragImg.setAttribute("class", "drag");
      imagedragging = true;
      //  console.log('imagedragging is set true');
    });

    document.addEventListener("mousemove", function(event) {
      if (imagedragging) {
        //  console.log('mouse move and imagedragging is '+imagedragging);
        dragImg.style.top = (event.clientY - dragImg.clientHeight / 2) + "px";
        dragImg.style.left = (event.clientX - dragImg.clientWidth / 2) + "px";
      }
    });

    document.body.addEventListener("mouseup", function(event) {
      if (imagedragging) {
        //  console.log("mouseup detected");

        //reset position if not in clipboard
        dragImg.removeAttribute("class");
        //  console.log(dragImg.id+' here mouse is lifted at'+event.target.id);
        //  console.log('imagedragging='+imagedragging+'   and animate='+animate);
        if (event.target.id.slice(0, 3) == 'div')
          document.getElementById(event.target.id).style.backgroundColor = 'orange';
        if (dragImg.id == 'start') {
          start = 'b' + event.target.id.slice(3, );
          document.getElementById(event.target.id).style.backgroundColor = 'blue';
        } else if (dragImg.id == 'end') {
          final = 'b' + event.target.id.slice(3, );
          document.getElementById(event.target.id).style.backgroundColor = 'green';
        } else if (dragImg.id == 'pass') {
          pass = 'b' + event.target.id.slice(3, );
          document.getElementById(event.target.id).style.backgroundColor = 'orange';
        }
        dragImg.style.top = (event.clientY - dragImg.clientHeight / 2) + "px";
        dragImg.style.left = (event.clientX - dragImg.clientWidth / 2) + "px";

        dragImg = null;
        imagedragging = false;
        //console.log('imagedragging false');
      }
    });



  }
</script>



<!-- //////////////////////  this is war wall   //////////////////////////////// -->
<script type="text/javascript">
  function mousedown(e) {

    var b_id = 'b' + e.target.id.slice(3, );
    if (e.button == 0 && (!imagedragging)) {
      lclicked = true;
      if (!wall.includes('b' + e.target.id.slice(3, )) && e.target.id.slice(0, 3) == 'div') {
        if ('b' + e.target.id.slice(3, ) != start && 'b' + e.target.id.slice(3, ) != final) {

          //    console.log('entering s='+start+' f='+final+'  curr='+'b'+e.target.id.slice(3,));
          document.getElementById(e.target.id).style.backgroundColor = 'black';
          wall.push('b' + e.target.id.slice(3, ));
          console.log('b' + e.target.id.slice(3, ) + '  has been push to the wall');
        }
      }
    }
    else if(e.button==1 &&(!imagedragging))
    {
      middleclicked = true;
      if (!obstacles.includes('b' + e.target.id.slice(3, )) && e.target.id.slice(0, 3) == 'div') {

          //    console.log('entering s='+start+' f='+final+'  curr='+'b'+e.target.id.slice(3,));
          var element=document.getElementById(e.target.id)
          element.classList.add("fa","fa-lock");
          obstacles.push('b' + e.target.id.slice(3, ));
          console.log('b' + e.target.id.slice(3, ) + '  has been push to the obstacles');

      }

    }
    else if (e.button == 2) {
      rclicked = true;
      e.preventDefault();
      if (wall.includes('b' + e.target.id.slice(3, ))) {
        document.getElementById(e.target.id).style.backgroundColor = 'white';
        var ind = wall.indexOf('b' + e.target.id.slice(3, ));
        if (ind > -1) {
          wall.splice(ind, 1);
        }
      }
      if (obstacles.includes('b' + e.target.id.slice(3, ))) {
        document.getElementById(e.target.id).classList.remove("fa","fa-lock");
        var ind = obstacles.indexOf('b' + e.target.id.slice(3, ));
        if (ind > -1) {
          obstacles.splice(ind, 1);
        }
      }

    }
  }

  function mouseup(e) {
    if (e.button == 0) {
      lclicked = false;
    }
    if (e.button == 2) {
      e.preventDefault();
      rclicked = false;
    }
    if(e.button == 1)
    {
      e.preventDefault();
      middleclicked=false;
    }
  }

  function entering(e) {
    //  console.log('entering+ '+e.target.id+'with animate='+animate +" and imagedragging="+imagedragging);
    var b_id = 'b' + e.target.id.slice(3, );
    if (lclicked == true && (!imagedragging) && e.target.id.slice(0, 3) == 'div') {
      if (!wall.includes(b_id)) {
        if (b_id != start && b_id != final && b_id != pass) {
          //        console.log('entering s='+start+' f='+final+'  curr='+b_id);
          wall.push(b_id);
          console.log(b_id + ' has been pushed to the wall');
          document.getElementById(e.target.id).style.backgroundColor = 'black';


        }
      }
    }
    else if(middleclicked == true && (!imagedragging))
    {
      e.preventDefault();
      if (!obstacles.includes(b_id)) {
          obstacles.push(b_id);
          console.log(b_id + ' has been pushed to the obstacles');
          var element=document.getElementById(e.target.id)
          element.classList.add("fa","fa-lock");
      }
    }
    else if (rclicked == true && (!imagedragging)) {
      e.preventDefault();
      if (wall.includes(b_id)) {
        var ind = wall.indexOf(b_id);
        if (ind > -1) {
          wall.splice(ind, 1);
        }
        document.getElementById(e.target.id).style.backgroundColor = 'white';
        //      console.log(wall);
      }
      if(obstacles.includes(b_id))
      {
        var ind = obstacles.indexOf(b_id);
      if (ind > -1) {
        obstacles.splice(ind, 1);
      }
      document.getElementById(e.target.id).classList.remove("fa","fa-lock");

      }
    } else if (animate && imagedragging) {
      //  console.log('mosue has eneterd while dragging in '+e.target.id);
      //    document.getElementById(e.target.id).style.backgroundColor='purple';
      if (dragImg.id == 'end') {
                  console.log('  final is being dragged');
                  final = 'b' + e.target.id.slice(3, );
                  if(selected_algo=='A*')
                              {
                                        console.log('A* entering triggered');
                                        g=graphbuild();
                                        if(!pass)
                                            {
                                              distances=g.A_star(start,final);
                                              animation_without_pass(false);
                                            }
                                        else
                                            {
                                            distances=g.A_star(start,pass);
                                            animation_with_pass(false,true);
                                            }
                              }
                  else if(selected_algo=='djkastra')
                              {
                                      graphbuild();
                                      if(pass)
                                        {
                                            if(arraysEqual(wall,check_prev_wall) && arraysEqual(obstacles,check_prev_obstacles))
                                              {
                                                animation_with_pass(false,false);
                                                path=[];
                                                path2=[];

                                              }
                                              else {
                                                  g=graphbuild();
                                                  distances=g.djikstraAlgorithm(start);
                                                  animation_with_pass(false,true);
                                                  check_prev_wall=wall.slice();
                                                  obstacles=check_prev_obstacles.slice();
                                              }


                                        }
                                        else {

                                            if(arraysEqual(wall,check_prev_wall) && arraysEqual(obstacles,check_prev_obstacles))
                                            {
                                                animation_without_pass(false);
                                            }
                                            else {
                                                g=graphbuild();
                                                distances=g.djikstraAlgorithm(start);
                                                animation_without_pass(false);
                                                check_prev_wall=wall.slice();
                                                check_prev_obstacles=obstacles.slice();
                                            }

                                        }
                              }

      }
    //end of end image dragging
    else if(dragImg.id=='pass')
      {
        pass = 'b' + e.target.id.slice(3, );
        if(selected_algo=='A*')
          {
            g=graphbuild();
            distances=g.A_star(start,pass);
            animation_with_pass(false,true);


          }
        else if(selected_algo=='djkastra') {

              if(check_prev_pass_exist)
              {
                  if(arraysEqual(check_prev_wall,wall) && arraysEqual(obstacles,check_prev_obstacles))
                    {
                        console.log('|||||||||||||||||||');
                        g=graphbuild();
                        distances=g.djikstraAlgorithm(start);
                        animation_with_pass(false,true);
                    }
                  else {
                        g=graphbuild();
                        distances=g.djikstraAlgorithm(start);
                        animation_with_pass(false,true);
                        check_prev_wall=wall.slice();
                        check_prev_obstacles=obstacles.slice();
                  }
              }
              else {
                g=graphbuild();
                distances=g.djikstraAlgorithm(start);
                animation_with_pass(false,true);
                check_prev_wall=wall.slice();
                check_prev_obstacles=obstacles.slice();
              }
        }
      }  //end of pass image draging
    else if (dragImg.id=='start')
    {
        start = 'b' + e.target.id.slice(3, );
      if(selected_algo=='A_star')
        {
          g=graphbuild();

          if(!pass)
              {
                  distances=g.A_star(start,final);
                  animation_without_pass(false);
              }
          else {
            distances=g.A_star(start,pass);
            animation_with_pass(false,true);
          }
        }
      else if(selected_algo=='djkastra')
        {
          g=graphbuild();
          distances=g.djikstraAlgorithm(start);
          if(!pass)
            animation_without_pass(false);
          else {
            animation_with_pass(false,true);
          }
        }

    }
  }

}
</script>

<!-- prevernting the right click default of the google chrome -->

<script type="text/javascript">
  document.getElementById('graph').addEventListener('contextmenu', function(evt) {
    evt.preventDefault();
  }, false);
</script>




</html>
