{% load static %}
<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title></title>
    <link rel="stylesheet" href="{% static 'css/s.css'%}">
  </head>
  <body >
    <button onclick="myFunction()" style='width:500px;height:40px;background-color:green'>Try it</button>
    <img id='start' src="{% static 'images/start.png'%}" alt="Photo" width='16px' height='26px' style='margin:0;' draggable="true" ondragstart="drag(event)">
    <img id='end' src="{% static 'images/end.png'%}" alt="Photo" width='16px' height='26px' style='margin:0;' draggable="true" ondragstart="drag(event)">
    <br>
    {% for row in rows%}
    {% for col in cols %}

      <button type="button"  id='b_{{row}}_{{col}}' >
          <div id="div_{{row}}_{{col}}"  ondrop="drop(event)" ondragover="allowDrop(event)" style='margin:0px auto 0px auto  ;width:30px;height:30px;display:block;' onmouseenter='entering(event)' onmousedown="mousedown(event)" onmouseup="mouseup(event)"></div>

      </button>

    {%endfor%}
    {% endfor%}

  </body>



<script type="text/javascript">
var start;
var final;
var clicked;
var wall=[];
function sleep(milliseconds) {
  var start = new Date().getTime();
  for (var i = 0; i < 1e7; i++) {
    if ((new Date().getTime() - start) > milliseconds){
      break;
    }
  }
}



class Graph {
   constructor() {
      this.edges = {};
      this.nodes = [];
   }
   addNode(node) {
      this.nodes.push(node);
      this.edges[node] = [];
   }
   addEdge(node1, node2) {
      this.edges[node1].push(node2);
      this.edges[node2].push(node1);
   }

   addDirectedEdge(node1, node2, weight = 1) {
       this.edges[node1].push({ node: node2, weight: weight });
    }

   display() {
      let graph = ""; this.nodes.forEach(node => {
         graph += node + "->" + this.edges[node].join(", ") + "\n";
      });
  //    console.log(graph);
   }
   djikstraAlgorithm(startNode) {
      let distances = {};

      // Stores the reference to previous nodes

      let pq = new PriorityQueue(this.nodes.length * this.nodes.length);

      // Set distances to all nodes to be infinite except startNode
      distances[startNode] = 0;
      pq.enqueue(startNode, 0);
      this.nodes.forEach(node => {
         if (node !== startNode) distances[node] = Infinity;
         prev[node] = null;
      });

      while (!pq.isEmpty()) {
         let minNode = pq.dequeue();
         let currNode = minNode.data;
         let weight = minNode.priority;
         this.edges[currNode].forEach(neighbor => {
            let alt = distances[currNode] + neighbor.weight;
            if (alt < distances[neighbor.node]) {
               distances[neighbor.node] = alt;
               prev[neighbor.node] = currNode;
               pq.enqueue(neighbor.node, distances[neighbor.node]);

            }

         });


      }

     var sortable = [];
     for (var vehicle in distances) {
        sortable.push([vehicle, distances[vehicle]]);
     }

     sortable.sort(function(a, b) {
        return a[1] - b[1];
       });





     return sortable;
   }





}
class PriorityQueue {
   constructor(maxSize) {
      // Set default max size if not provided
      if (isNaN(maxSize)) {
         maxSize = 10;
       }
      this.maxSize = maxSize;
      // Init an array that'll contain the queue values.
      this.container = [];
   }
   // Helper function to display all values while developing
   display() {
  //    console.log(this.container);
   }
   // Checks if queue is empty
   isEmpty() {
      return this.container.length === 0;
   }
   // checks if queue is full
   isFull() {
      return this.container.length >= this.maxSize;
   }
   enqueue(data, priority) {
      // Check if Queue is full
      if (this.isFull()) {
         console.log("Queue Overflow!");
         return;
      }
      let currElem = new this.Element(data, priority);
      let addedFlag = false;
      // Since we want to add elements to end, we'll just push them.
      for (let i = 0; i < this.container.length; i++) {
         if (currElem.priority < this.container[i].priority) {
            this.container.splice(i, 0, currElem);
            addedFlag = true; break;
         }
      }
      if (!addedFlag) {
         this.container.push(currElem);
      }
   }
   dequeue() {
   // Check if empty
   if (this.isEmpty()) {
      console.log("Queue Underflow!");
      return;
   }
   return this.container.pop();
}
peek() {
   if (isEmpty()) {
      console.log("Queue Underflow!");
      return;
   }
   return this.container[this.container.length - 1];
}
clear() {
   this.container = [];
   }
}
// Create an inner class that we'll use to create new nodes in the queue
// Each element has some data and a priority
PriorityQueue.prototype.Element = class {
   constructor(data, priority) {
      this.data = data;
      this.priority = priority;
   }
};




// var g = new Graph();
//
// for(let i=1;i<=20;i++)
//   {
//   for(let j=1;j<=44;j++)
//     {
//     g.addNode('b_'+i+'_'+j);
//     }
//   }
//
//
//
//   for(let i=1;i<=20;i++)
//     {
//     for(let j=1;j<=43;j++)
//       {
//       g.addDirectedEdge('b_'+i+'_'+j,'b_'+i+'_'+(j+1),1);
//       g.addDirectedEdge('b_'+i+'_'+(j+1),'b_'+i+'_'+j,1);
//
//       }
//     }
//     for(let i=1;i<=44;i++)
//       {
//       for(let j=1;j<=19;j++)
//         {
//         g.addDirectedEdge('b_'+j+'_'+i,'b_'+(j+1)+'_'+(i),1);
//         g.addDirectedEdge('b_'+(j+1)+'_'+(i),'b_'+j+'_'+i,1);
//         }
//       }

//console.log(g.edges)

/////////////////////////////////////////////////////////////////////////

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

var prev = {};



async function myFunction() {
var x = document.querySelectorAll("div");
  for (i = 1; i < x.length; i++) {
     x[i].style.backgroundColor = "white";
   }

///////////////////////////////////////////ecprer||||||||||||||||||||||||||||||||||||||||

let g=new Graph();
for(let i=1;i<=20;i++)
  {
  for(let j=1;j<=44;j++)
    {
    g.addNode('b_'+i+'_'+j);
    }
  }



  for(let i=1;i<=20;i++)
    {
    for(let j=1;j<=43;j++)
      {
      g.addDirectedEdge('b_'+i+'_'+j,'b_'+i+'_'+(j+1),1);
      g.addDirectedEdge('b_'+i+'_'+(j+1),'b_'+i+'_'+j,1);

      }
    }
    for(let i=1;i<=44;i++)
      {
      for(let j=1;j<=19;j++)
        {
        g.addDirectedEdge('b_'+j+'_'+i,'b_'+(j+1)+'_'+(i),1);
        g.addDirectedEdge('b_'+(j+1)+'_'+(i),'b_'+j+'_'+i,1);
        }
      }

///////////////////////////|||||||||||||||||||





for (item in wall)
  {
    document.getElementById('div'+wall[item].slice(1,)).style.backgroundColor='black';
  console.log('color changed to black '+wall[item]);

    nearest=g.edges[wall[item]];
    for (i in nearest)
    {
      nearest[i].weight=Infinity;


    }

  }
  for(k in g.edges)
  {
    for(t in g.edges[k])
      {
        if(wall.includes(g.edges[k][t].node))
        {
          g.edges[k][t].weight=Infinity;

        }
      }


  }
  console.log(g.djikstraAlgorithm(start));
  distances=g.djikstraAlgorithm(start);

var x = document.querySelectorAll("button");

 for (i = 1; i < x.length; i++) {
   x[i].style.backgroundColor = "white";
 }

document.getElementById(start).style.backgroundColor='blue';
document.getElementById(final).style.backgroundColor='red';
 for (item in distances)
 {
if(distances[item][1]!=Infinity)
{
 setTimeout(function () {
   alertFunc('div'+distances[item][0].slice(1,));
 }, 10);
}
 await sleep(11);
 if(distances[item][0]==final)
 {
  document.getElementById('div'+distances[item][0].slice(1,)).style.backgroundColor='red';
   break;
 }
 }

  document.getElementById('div'+start.slice(1,)).style.backgroundColor='blue';
  curr=final;
  if(prev[final]==null)
    {
      alert('TARGET CANNOT BE REACHED');
    }
    else {
      while(prev[curr]!=null)
        {
          document.getElementById('div'+prev[curr].slice(1,)).style.backgroundColor='#b6eb7a';
         curr=prev[curr];
        }
    }
 document.getElementById('div'+curr.slice(1,)).style.backgroundColor='blue';



}


function alertFunc(id) {
//  console.log('------------------------------'+id+'---------------------------');
  if(id!=start)
document.getElementById(id).style.backgroundColor='#a6dcef';
}


</script>

<!-- for drag and drop of start point -->


<script>
function allowDrop(ev)
  {
    ev.preventDefault();
  }

function drag(ev)
  {
    ev.dataTransfer.setData("text", ev.target.id);
    console.log('Drag is happening');
  }

function drop(ev)
  {
    ev.preventDefault();
    var data = ev.dataTransfer.getData("text");
    ev.target.appendChild(document.getElementById(data));
    console.log('Drop method called');
    var div_id=ev.target.id;
    var b_id='b'+div_id.slice(3,);
    if(data=='start')
    {

      start=b_id;
    }
    else if(data=='end')
    {
      final=b_id;
    }
  }
</script>
<!-- //////////////////////  this is war wall   //////////////////////////////// -->
<script type="text/javascript">

function mousedown(e)
  {
    if(e.button==0)
      {
        clicked=true;
        if(wall.includes('b'+e.target.id.slice(3,)))
          {
            document.getElementById(e.target.id).style.backgroundColor='white';
            var ind=wall.indexOf('b'+e.target.id.slice(3,));
            if (ind > -1)
              {
                wall.splice(ind, 1);
              }
          }
        else
           {
            document.getElementById(e.target.id).style.backgroundColor='violet';
            wall.push('b'+e.target.id.slice(3,));
           }
      }
  }

function mouseup(e)
  {
    if(e.button==0)
      {
        clicked=false;
      }
  }

function entering(e)
  {
    var b_id='b'+e.target.id.slice(3,);
    if(clicked==true)
      {
        if(wall.includes(b_id))
          {
            var ind=wall.indexOf(b_id);
            if (ind > -1)
              {
                wall.splice(ind, 1);
              }
            document.getElementById(e.target.id).style.backgroundColor='white';
            console.log(wall);
          }
        else
         {
           wall.push(b_id);
           document.getElementById(e.target.id).style.backgroundColor='violet';
         }
    }
}

</script>



</html>
