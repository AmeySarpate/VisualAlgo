{% load static %}
<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title></title>
    <link rel="stylesheet" href="{% static 'css/s.css'%}">
  </head>
  <body >
    <button onclick="myFunction()" style='width:500px;height:40px;background-color:green'>Try it</button>
    <img id='start' src="{% static 'images/start.png'%}" alt="Photo" width='16px' height='26px' style='margin:0;' draggable="true" ondragstart="drag(event)">
    <img id='end' src="{% static 'images/end.png'%}" alt="Photo" width='16px' height='26px' style='margin:0;' draggable="true" ondragstart="drag(event)">
    <br>
    {% for row in rows%}
    {% for col in cols %}

      <button type="button"  id='b_{{row}}_{{col}}' >
          <div id="div_{{row}}_{{col}}"  ondrop="drop(event)" ondragover="allowDrop(event)" style='margin:0px auto 0px auto  ;width:30px;height:30px;display:block;'></div>

      </button>

    {%endfor%}
    {% endfor%}

  </body>



<script type="text/javascript">
var start;
var final;

function sleep(milliseconds) {
  var start = new Date().getTime();
  for (var i = 0; i < 1e7; i++) {
    if ((new Date().getTime() - start) > milliseconds){
      break;
    }
  }
}



class Graph {
   constructor() {
      this.edges = {};
      this.nodes = [];
   }
   addNode(node) {
      this.nodes.push(node);
      this.edges[node] = [];
   }
   addEdge(node1, node2) {
      this.edges[node1].push(node2);
      this.edges[node2].push(node1);
   }

   addDirectedEdge(node1, node2, weight = 1) {
       this.edges[node1].push({ node: node2, weight: weight });
    }

   display() {
      let graph = ""; this.nodes.forEach(node => {
         graph += node + "->" + this.edges[node].join(", ") + "\n";
      });
  //    console.log(graph);
   }






}
class PriorityQueue {
   constructor(maxSize) {
      // Set default max size if not provided
      if (isNaN(maxSize)) {
         maxSize = 10;
       }
      this.maxSize = maxSize;
      // Init an array that'll contain the queue values.
      this.container = [];
   }
   // Helper function to display all values while developing
   display() {
  //    console.log(this.container);
   }
   // Checks if queue is empty
   isEmpty() {
      return this.container.length === 0;
   }
   // checks if queue is full
   isFull() {
      return this.container.length >= this.maxSize;
   }
   enqueue(data, priority) {
      // Check if Queue is full
      if (this.isFull()) {
         console.log("Queue Overflow!");
         return;
      }
      let currElem = new this.Element(data, priority);
      let addedFlag = false;
      // Since we want to add elements to end, we'll just push them.
      for (let i = 0; i < this.container.length; i++) {
         if (currElem.priority < this.container[i].priority) {
            this.container.splice(i, 0, currElem);
            addedFlag = true; break;
         }
      }
      if (!addedFlag) {
         this.container.push(currElem);
      }
   }
   dequeue() {
   // Check if empty
   if (this.isEmpty()) {
      console.log("Queue Underflow!");
      return;
   }
   return this.container.pop();
}
peek() {
   if (isEmpty()) {
      console.log("Queue Underflow!");
      return;
   }
   return this.container[this.container.length - 1];
}
clear() {
   this.container = [];
   }
}
// Create an inner class that we'll use to create new nodes in the queue
// Each element has some data and a priority
PriorityQueue.prototype.Element = class {
   constructor(data, priority) {
      this.data = data;
      this.priority = priority;
   }
};




let g = new Graph();

for(let i=1;i<=20;i++)
  {
  for(let j=1;j<=44;j++)
    {
    g.addNode('b_'+i+'_'+j);
    }
  }



  for(let i=1;i<=20;i++)
    {
    for(let j=1;j<=43;j++)
      {
      g.addDirectedEdge('b_'+i+'_'+j,'b_'+i+'_'+(j+1),1);
      g.addDirectedEdge('b_'+i+'_'+(j+1),'b_'+i+'_'+j,1);

      }
    }
    for(let i=1;i<=44;i++)
      {
      for(let j=1;j<=19;j++)
        {
        g.addDirectedEdge('b_'+j+'_'+i,'b_'+(j+1)+'_'+(i),1);
        g.addDirectedEdge('b_'+(j+1)+'_'+(i),'b_'+j+'_'+i,1);
        }
      }

//console.log(g.edges)

/////////////////////////////////////////////////////////////////////////

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

var prev = {};
function djikstraAlgorithm(startNode) {
   let distances = {};

   // Stores the reference to previous nodes

   let pq = new PriorityQueue(g.nodes.length * g.nodes.length);

   // Set distances to all nodes to be infinite except startNode
   distances[startNode] = 0;
   pq.enqueue(startNode, 0);
   g.nodes.forEach(node => {
      if (node !== startNode) distances[node] = Infinity;
      prev[node] = null;
   });

   while (!pq.isEmpty()) {
      let minNode = pq.dequeue();
      let currNode = minNode.data;
      let weight = minNode.priority;
      g.edges[currNode].forEach(neighbor => {
         let alt = distances[currNode] + neighbor.weight;
         if (alt < distances[neighbor.node]) {
            distances[neighbor.node] = alt;
            prev[neighbor.node] = currNode;
            pq.enqueue(neighbor.node, distances[neighbor.node]);

         }

      });


   }

  var sortable = [];
  for (var vehicle in distances) {
     sortable.push([vehicle, distances[vehicle]]);
  }

  sortable.sort(function(a, b) {
     return a[1] - b[1];
    });





  return sortable;
}





///////////////////////////////////////////////////////////////////////


async function myFunction() {
//console.log('hapdadjwdwabwdh');
  console.log(djikstraAlgorithm(start));
  distances=djikstraAlgorithm(start);
//console.log('hapdadjwdwabwdh');

var x = document.querySelectorAll("button");

 for (i = 1; i < x.length; i++) {
   x[i].style.backgroundColor = "white";
 }

document.getElementById(start).style.backgroundColor='blue';
document.getElementById(final).style.backgroundColor='red';
 for (item in distances)
 {
 //myVar = setTimeout(function(){alertFunc(distances[item][0]);},200);
if(distances[item][1]!=Infinity)
{
  console.log('------------------------------'+distances[item][0]+' is #feceabdlist');
 setTimeout(function () {
   console.log('alter is going to call for '+distances[item][0]);
   alertFunc(distances[item][0]);
 }, 10);
}
 await sleep(11);
 if(distances[item][0]==final)
 {
  document.getElementById(distances[item][0]).style.backgroundColor='red';
   break;
 }
 }

  document.getElementById(start).style.backgroundColor='blue';
//console.log(prev);
  curr=final;
//  console.log('----------------------------------------------the prev of final:');
  if(prev[final]==null)
    {
      alert('TARGET CANNOT BE REACHED');
    }
    else {
      while(prev[curr]!=null)
        {
          document.getElementById(prev[curr]).style.backgroundColor='#b6eb7a';
         curr=prev[curr];
        }
    }
 document.getElementById(curr).style.backgroundColor='blue';



}


function alertFunc(id) {
  console.log('------------------------------'+id+'---------------------------');
  if(id!=start)
document.getElementById(id).style.backgroundColor='#a6dcef';
}


</script>

<script type="text/javascript">
var wall=[];
document.addEventListener('click', function(e) {
  e = e;
  var target = e.target;
  console.log('THIs  thing have been pressed'+target.id);
//  console.log(e.which);
  if(target.id.slice(0,3)=='div')
      {

        if(start && final)
        {

                  wall.push('b'+target.id.slice(3,));


        }
      //   if (start)
      // {
      //   if(!final)
      //   {
      //
      //     final='b'+target.id.slice(3,);
      //     document.getElementById(final).style.backgroundColor='red';
      //   }
      // }
      // else {
      //   start='b'+target.id.slice(3,);
      //   document.getElementById(start).style.backgroundColor='blue';
      // }


      }

      for (item in wall)
        {
          document.getElementById(wall[item]).style.backgroundColor='Black';


          nearest=g.edges[wall[item]];
          for (i in nearest)
          {
            nearest[i].weight=Infinity;


          }

        }
        for(k in g.edges)
        {
          for(t in g.edges[k])
            {
              if(wall.includes(g.edges[k][t].node))
              {
                g.edges[k][t].weight=Infinity;

              }
            }


        }

}, false);



</script>

<!-- for drag and drop of start point -->


<script>
function allowDrop(ev) {
  ev.preventDefault();
}

function drag(ev) {
  ev.dataTransfer.setData("text", ev.target.id);
  console.log('Drag is happening');

}

function drop(ev) {
  ev.preventDefault();
  var data = ev.dataTransfer.getData("text");
  console.log('in drop data=');
  ev.target.appendChild(document.getElementById(data));
  console.log('Drop method called');
//  start=ev.target.id;
  var div_id=ev.target.id;
  var b_id='b'+div_id.slice(3,);
  console.log('this is the button id of the droped flag'+b_id);
  if(data=='start')
  {

    start=b_id;
    console.log('redfinging the start');
  }
  else if(data=='end')
  {
  console.log('radifing the final');
    final=b_id;
  }
}
</script>





</html>
