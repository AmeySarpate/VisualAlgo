{% load static %}
<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title></title>
    <link rel="stylesheet" href="{% static 'css/s.css'%}">
  </head>
  <body >

<ul>
  <li><button id='nav1'onclick="myFunction()">Djkastra</button></li>
  <li><button id='nav2'>A* algorithm</button></li>
  <li><button id='nav3'>3rd algo</button></li>

</ul>

    <img id='start' src="{% static 'images/start.png'%}" alt="Photo" width='14px' height='14px' style='margin:0;' draggable="true" ondragstart="drag(event)">
    <img id='end' src="{% static 'images/end.png'%}" alt="Photo" width='14px' height='14px' style='margin:0;' draggable="true" ondragstart="drag(event)">
    <img id='pass' src="{% static 'images/pass.png'%}" alt="Photo" width='14px' height='14px' style='margin:0;' draggable="true" ondragstart="drag(event)">
    <br>
    <div id='graph'unselectable="on"
 onselectstart="return false;" >
     <table style="width:100%">
      {% for row in rows%}
      <tr>


      {% for col in cols %}
        <td  id='b_{{row}}_{{col}}' style="width:15px;height:15px;padding:0px;margin:0px;">

            <div id="div_{{row}}_{{col}}"  ondrop="drop(event)" ondragover="allowDrop(event)" style='margin:0px;width:21.4px;height:19px;display:block;' onmouseenter='entering(event)' onmousedown="mousedown(event)" onmouseup="mouseup(event)"></div>

        </td>
      {%endfor%}
      </tr>
      {% endfor%}
    </table>
    </div>


  </body>

<!--varible declaration and initials-->
<script type="text/javascript">
var start;
var final;
var pass;
var lclicked;
var rclicked;
var wall=[];
var imagedragging=false;
var path=[];
var path2=[];
var prev=[];
var prev2=[];
var animate=false;

var x = document.querySelectorAll("div");
  for (i = 1; i < x.length; i++) {
     x[i].style.backgroundColor = "white";
   }

</script>

<!-- class declaration -->
<script type="text/javascript">
class Graph {
   constructor() {
      this.edges = {};
      this.nodes = [];
   }
   addNode(node) {
      this.nodes.push(node);
      this.edges[node] = [];
   }
   addEdge(node1, node2) {
      this.edges[node1].push(node2);
      this.edges[node2].push(node1);
   }

   addDirectedEdge(node1, node2, weight = 1) {
       this.edges[node1].push({ node: node2, weight: weight });
    }

   display() {
      let graph = ""; this.nodes.forEach(node => {
         graph += node + "->" + this.edges[node].join(", ") + "\n";
      });
  //    console.log(graph);
   }
   djikstraAlgorithm(startNode) {
      let distances = {};

      // Stores the reference to previous nodes

      let pq = new PriorityQueue(this.nodes.length * this.nodes.length);

      // Set distances to all nodes to be infinite except startNode
      distances[startNode] = 0;
      pq.enqueue(startNode, 0);
      this.nodes.forEach(node => {
         if (node !== startNode) distances[node] = Infinity;
         prev[node] = null;
      });

      while (!pq.isEmpty()) {
         let minNode = pq.dequeue();
         let currNode = minNode.data;
         let weight = minNode.priority;
         this.edges[currNode].forEach(neighbor => {
            let alt = distances[currNode] + neighbor.weight;
            if (alt < distances[neighbor.node]) {
               distances[neighbor.node] = alt;
               prev[neighbor.node] = currNode;
               pq.enqueue(neighbor.node, distances[neighbor.node]);

            }
         });
      }

      var sortable = [];
      for (var n in distances) {sortable.push([n, distances[n]]);}
      sortable.sort(function(a, b) {return a[1] - b[1];});
      return sortable;
   }
}


class PriorityQueue {
   constructor(maxSize) {
      // Set default max size if not provided
      if (isNaN(maxSize)) {
         maxSize = 10;
       }
      this.maxSize = maxSize;
      // Init an array that'll contain the queue values.
      this.container = [];
   }
   // Helper function to display all values while developing
   display() {
  //    console.log(this.container);
   }
   // Checks if queue is empty
   isEmpty() {
      return this.container.length === 0;
   }
   // checks if queue is full
   isFull() {
      return this.container.length >= this.maxSize;
   }
   enqueue(data, priority) {
      // Check if Queue is full
      if (this.isFull()) {
         console.log("Queue Overflow!");
         return;
      }
      let currElem = new this.Element(data, priority);
      let addedFlag = false;
      // Since we want to add elements to end, we'll just push them.
      for (let i = 0; i < this.container.length; i++) {
         if (currElem.priority < this.container[i].priority) {
            this.container.splice(i, 0, currElem);
            addedFlag = true; break;
         }
      }
      if (!addedFlag) {
         this.container.push(currElem);
      }
   }
   dequeue() {
   // Check if empty
   if (this.isEmpty()) {
      console.log("Queue Underflow!");
      return;
   }
   return this.container.pop();
  }
  peek() {
   if (isEmpty()) {
      console.log("Queue Underflow!");
      return;
   }
   return this.container[this.container.length - 1];
  }
  clear() {
   this.container = [];
   }
}


PriorityQueue.prototype.Element = class {
   constructor(data, priority) {
      this.data = data;
      this.priority = priority;
   }
};
</script>

<!-- path propagater and highlighter functions -->
<script type="text/javascript">

function pathhighlighter(id)
{
  if(id!=start)
  {
  document.getElementById(id).style.backgroundColor='yellow';
  document.getElementById('b'+id.slice(3,)).style.border="0px solid yellow";
  document.getElementById('b'+id.slice(3,)).style.margin="0px";
  }
}

function propagater(id) {
  if(id!=start)
  {
  document.getElementById(id).style.backgroundColor='#a6dcef';
  document.getElementById('b'+id.slice(3,)).style.border="0px solid #a6dcef";
  document.getElementById('b'+id.slice(3,)).style.margin="0px";
  }
}

function propagater2(id) {
//  console.log('------------------------------'+id+'---------------------------');
  if(id!=start)
  {
  document.getElementById(id).style.backgroundColor='pink';
  document.getElementById('b'+id.slice(3,)).style.border="0px solid pink";
  document.getElementById('b'+id.slice(3,)).style.margin="0px";
  }
}
</script>


sleep function
<script type="text/javascript">

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

</script>

<!-- other very important breaked function  -->
<script type="text/javascript">
function graphbuild()
{
  animate=true;
  var x = document.querySelectorAll("div");
  for (i = 1; i < x.length; i++) {
     x[i].style.backgroundColor = "white";
   }
  var k=document.querySelectorAll('td');
  for(i=1;i<k.length;i++)
  {
    k[i].style.border="1px solid black";
  }
let g=new Graph();
for(let i=1;i<=40;i++)
  {
  for(let j=1;j<=79;j++)
    {
    g.addNode('b_'+i+'_'+j);
    }
  }



  for(let i=1;i<=40;i++)
    {
    for(let j=1;j<=78;j++)
      {
      g.addDirectedEdge('b_'+i+'_'+j,'b_'+i+'_'+(j+1),1);
      g.addDirectedEdge('b_'+i+'_'+(j+1),'b_'+i+'_'+j,1);

      }
    }
    for(let i=1;i<=79;i++)
      {
      for(let j=1;j<=39;j++)
        {
        g.addDirectedEdge('b_'+j+'_'+i,'b_'+(j+1)+'_'+(i),1);
        g.addDirectedEdge('b_'+(j+1)+'_'+(i),'b_'+j+'_'+i,1);
        }
      }


for (item in wall)
  {
    document.getElementById('div'+wall[item].slice(1,)).style.backgroundColor='black';
    nearest=g.edges[wall[item]];
    for (i in nearest)
    {
      nearest[i].weight=Infinity;


    }

  }
  for(k in g.edges)
  {
    for(t in g.edges[k])
      {
        if(wall.includes(g.edges[k][t].node))
        {
          g.edges[k][t].weight=Infinity;

        }
      }


  }
return g;
}




async function animating(g)
{

  path=[];
  if(!pass)
  {

   for (item in distances)
   {
  if(distances[item][1]!=Infinity)
  {
   setTimeout(function () {
     propagater('div'+distances[item][0].slice(1,));
   }, 0.002);
  }
   await sleep(0.003);
   if(distances[item][0]==final)
   {
    document.getElementById('div'+distances[item][0].slice(1,)).style.backgroundColor='red';
     break;
   }
   }

    document.getElementById('div'+start.slice(1,)).style.backgroundColor='blue';
    curr=final;
    if(prev[final]==null)
      {
        alert('TARGET CANNOT BE REACHED');
      }
      else {
        while(prev[curr]!=null)
          {
        //    document.getElementById('div'+prev[curr].slice(1,)).style.backgroundColor='#b6eb7a';
           path.push(prev[curr]);
           curr=prev[curr];
          }
          path.pop();
      //    console.log('this is the path : ');
      //    console.log(path);
      }
   document.getElementById('div'+curr.slice(1,)).style.backgroundColor='blue';
  for(i in path)
    {//console.log(i);
      setTimeout(function () {

      //  console.log(path[path.length-i]);
        pathhighlighter('div'+path[path.length-i-1].slice(1,));
      }, 24);

      await sleep(25);
      }




  }
  else {



      for (item in distances)
      {
       if(distances[item][1]!=Infinity)
       {
        setTimeout(function () {
        propagater('div'+distances[item][0].slice(1,));
        }, 0.002);
       }
      await sleep(0.003);
      if(distances[item][0]==pass)
      {
       document.getElementById('div'+distances[item][0].slice(1,)).style.backgroundColor='pink';
        break;
      }
      }
      curr=pass;
      if(prev[final]==null)
        {
          alert('TARGET CANNOT BE REACHED');
        }
        else {
        while(prev[curr]!=null)
          {
        //    document.getElementById('div'+prev[curr].slice(1,)).style.backgroundColor='#b6eb7a';
           path.push(prev[curr]);
           curr=prev[curr];
          }
          path.pop();
      //    console.log('this is the path : ');
      //    console.log(path);
      }
    prev=[];
    distances2=g.djikstraAlgorithm(pass);

      for (item in distances2)
      {
      if(distances2[item][1]!=Infinity)
      {
      setTimeout(function () {
        propagater2('div'+distances2[item][0].slice(1,));
      }, 0.002);
      }
      await sleep(0.003);
      if(distances2[item][0]==final)
      {
       document.getElementById('div'+distances2[item][0].slice(1,)).style.backgroundColor='pink';
        break;
      }
      }
      curr=final;
      var path2=[];
      if(prev[final]==null)
        {
          alert('TARGET CANNOT BE REACHED');
        }
        else {
          while(prev[curr]!=null)
            {
          //    document.getElementById('div'+prev[curr].slice(1,)).style.backgroundColor='#b6eb7a';
             path2.push(prev[curr]);
             curr=prev[curr];
            }
            path2.pop();
        //    console.log('this is the path : ');
        //    console.log(path);
        }
        /////////////////////
        for(i=0;i<path.length;i++)
          {
            path2.push(path[i]);
          }
        path=path2;
        for(i in path)
          {//console.log(i);
            setTimeout(function () {

            //  console.log(path[path.length-i]);
              pathhighlighter('div'+path[path.length-i-1].slice(1,));
            }, 24);

            await sleep(25);
            }

      path=[];
      prev=[];

    }
}
</script>


<script type="text/javascript">

async function myFunction() {
g=graphbuild();

distances=g.djikstraAlgorithm(start);
animating(g);

}
</script>

<!-- for drag and drop of start point ,pass point and end point -->


<script>
var dragImg;
function allowDrop(ev)
  {
    ev.preventDefault();
  }

function drag(ev)
  {  imagedragging=true;
    ev.dataTransfer.setData("text", ev.target.id);
  //  console.log('Drag is happening');
  // dragImg=ev.target;
  // dragImg.setAttribute("id", "drag");
  // dragging = true;
  //
  // document.addEventListener('mousedown', function documentMouseDown(){
  //   if (dragging) {
  //     dragImg.removeAttribute("id");
  //     dragging = false;
  //
  //     document.removeEventListener('mousedown', documentMouseDown);
  //   }
  // });

  }

function drop(ev)
  {
  imagedragging=false;
    ev.preventDefault();
    var data = ev.dataTransfer.getData("text");
    ev.target.appendChild(document.getElementById(data));
  //  console.log('Drop method called');
    var div_id=ev.target.id;
    var b_id='b'+div_id.slice(3,);
    lclicked=false;
    if(data=='start')
    {

      start=b_id;
    }
    else if(data=='end')
    {
      final=b_id;
    }
    else if(data=='pass')
    {
      pass=b_id;
    }
  }
</script>



<!-- //////////////////////  this is war wall   //////////////////////////////// -->
<script type="text/javascript">

function mousedown(e)
  {

      var b_id='b'+e.target.id.slice(3,);
    if(e.button==0 && (!imagedragging))
      {
        lclicked=true;
        if(!wall.includes('b'+e.target.id.slice(3,)) && e.target.id.slice(0,3)=='div')
          {
            if('b'+e.target.id.slice(3,)!=start && 'b'+e.target.id.slice(3,)!=final)
            {

                console.log('entering s='+start+' f='+final+'  curr='+'b'+e.target.id.slice(3,));
            document.getElementById(e.target.id).style.backgroundColor='black';
            wall.push('b'+e.target.id.slice(3,));
          }
           }
      }
      else if(e.button==2)
        {
          rclicked=true;
          e.preventDefault();
          if(wall.includes('b'+e.target.id.slice(3,)))
            {
              document.getElementById(e.target.id).style.backgroundColor='white';
              var ind=wall.indexOf('b'+e.target.id.slice(3,));
              if (ind > -1)
                {
                  wall.splice(ind, 1);
                }
            }
        }
  }

function mouseup(e)
  {
    if(e.button==0)
      {
        lclicked=false;
      }
    if(e.button==2)
      {e.preventDefault();
        rclicked=false;
      }
  }

function entering(e)
  {
    var b_id='b'+e.target.id.slice(3,);
    if(lclicked==true && (!imagedragging) && e.target.id.slice(0,3)=='div')
      {
        if(!wall.includes(b_id))
          {
          if(b_id!=start && b_id !=final && b_id!=pass)
          {
            console.log('entering s='+start+' f='+final+'  curr='+b_id);
           wall.push(b_id);
           document.getElementById(e.target.id).style.backgroundColor='black';


          }
         }
    }
    else if(rclicked==true && (!imagedragging))
      {
        e.preventDefault();
        if(wall.includes(b_id))
          {
            var ind=wall.indexOf(b_id);
            if (ind > -1)
              {
                wall.splice(ind, 1);
              }
            document.getElementById(e.target.id).style.backgroundColor='white';
            console.log(wall);
          }
      }
}


</script>

<!-- prevernting the right click default of the google chrome -->

<script type="text/javascript">

document.getElementById('graph').addEventListener('contextmenu', function(evt) {
  evt.preventDefault();
}, false);

</script>




</html>
